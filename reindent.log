2025-01-09 22:29:19,656 - ERROR: Error while reindenting file {'blob_id': 'f33d2ba9f4e5875a6212ce3ca021da2e1b3935a3', 'path': '/homework_class2.py', 'content_id': 'd49d5cd861701f56e5966567973525b5d068a34f', 'language': 'Python', 'length_bytes': 4856, 'detected_licenses': [], 'license_type': 'no_license', 'src_encoding': 'UTF-8', 'is_vendor': False, 'is_generated': False, 'alphanum_fraction': 0.5488975644111633, 'alpha_fraction': 0.5180285573005676, 'num_lines': 126, 'avg_line_length': 29.595237731933594, 'max_line_length': 111, 'content': '# 1)Дан массив из словарей\u2028\n# 1.1) отсортировать массив из словарей по значению ключа ‘age\'\u2028\n# 1.2) сгруппировать данные по значению ключа \'city\'\u2028\n# вывод должен быть такого вида :\n# result = {\n#    \'Kiev\':  [{\'name\': \'Viktor\', \'age\': 30 },\n#               {\'name\': \'Andrey\', \'age\': 34}],\n#    \'Dnepr\': [{\'name\': \'Maksim\', \'age\': 20 },\n#               {\'name\': \'Artem\', \'age\': 50}],\n#    \'Lviv\': [{\'name\': \'Vladimir\', \'age\': 32 },\n#              {\'name\': \'Dmitriy\', \'age\': 21}]}\n\nfrom itertools import groupby\nfrom operator import itemgetter\nfrom collections import Counter\n\ndata = [\n    {\'name\': \'Viktor\', \'city\': \'Kiev\', \'age\': 30},\n    {\'name\': \'Maksim\', \'city\': \'Dnepr\', \'age\': 20},\n    {\'name\': \'Vladimir\', \'city\': \'Lviv\', \'age\': 32},\n    {\'name\': \'Andrey\', \'city\': \'Kiev\', \'age\': 34},\n    {\'name\': \'Artem\', \'city\': \'Dnepr\', \'age\': 50},\n    {\'name\': \'Dmitriy\', \'city\': \'Lviv\', \'age\': 21}]\n\n\ndef task_1_1():\n    data.sort(key=lambda k: k["age"], )\n    return data[:]\n\n\nprint("1.1) отсортировать массив из словарей по значению ключа ‘age\'\u2028: ", task_1_1())\n\n\n# Задание 1.2 не осилил всё на что хватило сил:\ndef task_1_2():\n    data1 = [\n        {\'name\': \'Viktor\', \'city\': \'Kiev\', \'age\': 30},\n        {\'name\': \'Maksim\', \'city\': \'Dnepr\', \'age\': 20},\n        {\'name\': \'Vladimir\', \'city\': \'Lviv\', \'age\': 32},\n        {\'name\': \'Andrey\', \'city\': \'Kiev\', \'age\': 34},\n        {\'name\': \'Artem\', \'city\': \'Dnepr\', \'age\': 50},\n        {\'name\': \'Dmitriy\', \'city\': \'Lviv\', \'age\': 21}]\n    data1.sort(key=itemgetter(\'city\'))\n    return data1\n\n\nprint("Задание 1.2 не осилил всё на что хватило сил:", task_1_2())\n\n\n# =======================================================\n# 2) У вас есть последовательность строк.\n# Необходимо определить наиболее часто встречающуюся строку в последовательности.\n# Например:\n# def most_frequent(list_var):\n# your code is here\n#    return\n# most_frequent([\'a\', \'a\', \'bi\', \'bi\', \'bi\']) == \'bi\'\n\ndef task_2():\n    string = [\'a\', \'a\', \'bi\', \'bi\', \'bi\', \'ggg\', \'ggg\', \'ggg\', \'ggg\']\n    max_occur = Counter(string)\n    return max_occur.most_common(1)\n\n\nprint("2) Наиболее часто встречающуюся строку в последовательности:", task_2())\n\n\n# =======================================================\n# 3) Дано целое число. Необходимо подсчитать произведение всех цифр в этом числе, за исключением нулей.\n# Например:\n# Дано число 123405. Результат будет: 1*2*3*4*5=120.\n\ndef task_3():\n    num = 1023405\n    num_list = [int(x) for x in str(num)]\n    list1 = sorted(num_list)\n    prod = 1\n    for i in list1:\n        if i != 0:\n            prod *= i\n    return prod\n\n\nprint("3) Подсчитать произведение всех цифр в этом числе, за исключением нулей: ", task_3())\n\n\n# =======================================================\n# 4) Есть массив с положительными числами и число n (def some_function(array, n)).\n# Необходимо найти n-ую степень элемента в массиве с индексом n. Если n за границами массива, тогда вернуть -1.\n\n\ndef task_4():\n    n = 5\n    num_list = [1, 2, 3, 4, 5]\n    if n >= len(num_list):\n        return "-1"\n    else:\n        a = num_list.pop(n)\n        return a ** n\n\n\nprint("4) Найти n-ую степень элемента в массиве с индексом n. Если n за границами массива, тогда вернуть -1: ",\n      task_4())\n\n\n# =======================================================\n# 5) Есть строка со словами и числами, разделенными пробелами (один пробел между словами и/или числами).\n# Слова состоят только из букв. Вам нужно проверить есть ли в исходной строке три слова\xa0подряд.\n# Для примера, в строке "hello 1\xa0one two three\xa015 world" есть три слова подряд.\ndef task_5():\n    str = "hello 1 one two three four 15 world"\n    cnt = 0\n    for i in str.split():\n        if i.isalpha():\n            cnt += 1\n            if cnt == 3:\n                return True\n        else:\n            cnt = 0\n\n\nprint("5) Есть ли в исходной строке три слова\xa0подряд: ", task_5())\n'} : exceptions must derive from BaseException
2025-01-09 22:29:20,013 - ERROR: Error while reindenting file {'blob_id': 'e9151617042cf298f130b60f28a9e6527b8cb425', 'path': '/preprocess.py', 'content_id': '9fbf5f4141eca39eaa1bad87f1b86f0c2e1c1724', 'language': 'Python', 'length_bytes': 16837, 'detected_licenses': [], 'license_type': 'no_license', 'src_encoding': 'UTF-8', 'is_vendor': False, 'is_generated': False, 'alphanum_fraction': 0.44882315397262573, 'alpha_fraction': 0.41127148270606995, 'num_lines': 358, 'avg_line_length': 45.63966369628906, 'max_line_length': 141, 'content': 'import os\nimport pytesseract\nimport math\nimport csv\nimport re\nimport cv2\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\nclass meta_info :\n\n    @staticmethod\n    def frame_classifier(img_dir, avg_threshold=1.5, std_threshold=0.5):\n\n        frame = cv2.imread(img_dir, cv2.COLOR_RGB2BGR)\n        frame_parts = frame[26:666, :, :]\n\n        # # intensity\n        # intensity = np.mean(frame_parts)\n\n        # statistics\n        b_avg = np.mean(frame_parts[:, :, 0])\n        g_avg = np.mean(frame_parts[:, :, 1])\n        r_avg = np.mean(frame_parts[:, :, 2])\n        avg_std = np.std([b_avg, g_avg, r_avg])\n\n        b_std = np.std(frame_parts[:, :, 0])\n        g_std = np.std(frame_parts[:, :, 1])\n        r_std = np.std(frame_parts[:, :, 2])\n        std_std = np.std([b_std, g_std, r_std])\n\n        if avg_std < avg_threshold:\n\n            if std_std < std_threshold: img = "THR"\n            else: img = "RGB"\n\n        else: img = "RGB"\n\n        return img\n\n    def geo_info(self,\n                 frame_folder_dir,\n                 ) :\n\n        # frame meta dict\n        frame_meta_list = []\n        meta_list = ["name", "Tlat", "Tlon", "Rng", "Alat", "Alon", "Az", "El", "Date", "Time", "img"]\n\n        # frame folder dir generation\n        frame_nm_list = os.listdir(frame_folder_dir)\n        for frame_nm in tqdm(frame_nm_list) :\n\n            frame_dir = os.path.join(frame_folder_dir, frame_nm)\n            img = meta_info.frame_classifier(img_dir=frame_dir)\n\n            frame = cv2.imread(frame_dir, cv2.IMREAD_GRAYSCALE)\n            # frame = np.array(Image.open(frame_dir))\n\n            # cv2 : order of coordinates = [y, x]\n            Tlat = frame[668:690, 118:251]\n            Tlon = frame[668:690, 331:468]\n            Rng = frame[668:690, 537:958]\n            Alat = frame[697:716, 75:215]\n            Alon = frame[697:716, 341:488]\n            Az = frame[697:716, 770:845]\n            El = frame[697:716, 918:989]\n            Date = frame[697:716, 1010:1160]\n            Time = frame[697:716, 1160:1277]\n\n            # save meta info of a frame in dict type\n            frame_dict = {}\n            frame_dict[meta_list[0]] = frame_nm\n            frame_dict[meta_list[10]] = img\n\n            frame_dict[meta_list[1]] = pytesseract.image_to_string(Tlat, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[1]] == "\x0c" :\n                frame_dict[meta_list[1]] = "None"\n                print("Tlat None")\n\n            frame_dict[meta_list[2]] = pytesseract.image_to_string(Tlon, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[2]] == "\x0c" :\n                frame_dict[meta_list[2]] = "None"\n                print("Tlon None")\n\n            frame_dict[meta_list[3]] = pytesseract.image_to_string(Rng, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[3]] == "\x0c" :\n                frame_dict[meta_list[3]] = "None"\n                print("Rng None")\n\n            frame_dict[meta_list[4]] = pytesseract.image_to_string(Alat, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[4]] == "\x0c" :\n                frame_dict[meta_list[4]] = "None"\n                print("Alat None")\n\n            frame_dict[meta_list[5]] = pytesseract.image_to_string(Alon, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[5]] == "\x0c" :\n                frame_dict[meta_list[5]] = "None"\n                print("Alon None")\n\n            frame_dict[meta_list[6]] = pytesseract.image_to_string(Az, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[6]] == "\x0c" :\n                frame_dict[meta_list[6]] = "None"\n                print("Az None")\n\n            frame_dict[meta_list[7]] = pytesseract.image_to_string(El, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[7]] == "\x0c" :\n                frame_dict[meta_list[7]] = "None"\n                print("El None")\n\n            frame_dict[meta_list[8]] = pytesseract.image_to_string(Date, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[8]] == "\x0c" :\n                frame_dict[meta_list[8]] = "None"\n                print("Date None")\n\n            frame_dict[meta_list[9]] = pytesseract.image_to_string(Time, lang=None, config=\'--psm 8\')\n            if frame_dict[meta_list[9]] == "\x0c" :\n                frame_dict[meta_list[9]] = "None"\n                print("Time None")\n\n            frame_meta_list.append(frame_dict)\n\n        # dict to csv format file\n        with open("E:\\\\2021_coastguard\\\\frame\\\\D\\\\extract_geoinfo_with_img.csv", "w", encoding=\'UTF-8\', newline=\'\', ) as f:\n            writer = csv.DictWriter(f, fieldnames=meta_list)\n            writer.writeheader()\n            for data in frame_meta_list:\n                writer.writerow(data)\n\n        return frame_meta_list\n\n    def interpolation(self,\n                      input,\n                      output,\n                      interpolation=False):\n\n        # input\n        f = open(input, \'r\', encoding=\'UTF-8\', newline="")\n        f = csv.reader(f)\n\n        # pattern reg\n        Loc_p = re.compile(\'(\\d{1,3})(\\D+)(\\d{1,3})(\\D+)(\\d{1,3})\')  # Tlat, Tlon, ALat, Alon, Az, El\n        Pos_p = re.compile(\'([+-]?\\d{1,2})(\\D+)(\\d{1,2})\')  # Az, El\n        Date_p = re.compile(\'(\\d{2})-([a-zA-Z]{3})-(\\d{4})\')  # Date\n        Time_p = re.compile("(\\d{2}):(\\d{2}):(\\d{2})")  # Time\n\n        # geo-data\n        meta_list = ["name", "Tlat", "Tlon", "Rng", "Alat", "Alon", "Az", "El", "Date", "Time", "Img"]\n        interpolated_meta = [] # 최종결과값 (str 타입으로 변환된 값 - 연산이 불가능한 형태라고 가정)\n        temp_meta = [] # 연산이 가능한 형태(튜플)로 저장된 값\n\n        for idx, line in enumerate(f) :\n            re_frame_dict = {} # 현재 decoding하고 있는 값\n            if idx == 0 : continue # 맨 처음 열은 열 별 이름이므로 패스\n\n            Tlat_re = re.findall(Loc_p, line[1])\n            if Tlat_re != []: Tlat = str(Tlat_re[0][0])+\'°\'+str(Tlat_re[0][2])+"."+str(Tlat_re[0][4])+"\'"\n            else : Tlat = None # No fitted in the shape of re, considering Error : None\n            Tlon_re = re.findall(Loc_p, line[2])\n            if Tlon_re != []: Tlon = str(Tlon_re[0][0])+\'°\'+str(Tlon_re[0][2])+"."+str(Tlon_re[0][4])+"\'"\n            else : Tlon = None\n            Alat_re = re.findall(Loc_p, line[4])\n            if Alat_re != []: Alat = str(Alat_re[0][0])+\'°\'+ str(Alat_re[0][2])+"."+str(Alat_re[0][4])+"\'"\n            else : Alat = None\n            Alon_re = re.findall(Loc_p, line[5])\n            if Alon_re != []: Alon = str(Alon_re[0][0])+\'°\'+str(Alon_re[0][2] +"."+str(Alon_re[0][4]))+"\'"\n            else : Alon = None\n            Az_re = re.findall(Pos_p, line[6])\n            if Az_re != []: Az = str(Az_re[0][0]) + "." + str(Az_re[0][2]) + \'°\'\n            else : Az = None\n            El_re = re.findall(Pos_p, line[7])\n            if El_re != []: El = str(El_re[0][0]) + "." + str(El_re[0][2]) + \'°\'\n            else : El = None\n            Date_re = re.findall(Date_p, line[8])\n            if Date_re != [] : Date = str(Date_re[0][0])+"-"+str(Date_re[0][1])+"-"+str(Date_re[0][2])\n            else : Date = None\n            Time_re = re.findall(Time_p, line[9])\n            if Time_re != [] : Time = str(Time_re[0][0])+":"+str(Time_re[0][1])+":"+str(Time_re[0][2])\n            else : Time = None\n            temp_meta.append([line[0], Tlat_re, Tlon_re, line[3], Alat_re, Alon_re, Az_re, El_re, Date_re, Time_re])\n        print(temp_meta)\n        interval = np.zeros((10))\n        for idx in range(len(temp_meta)):\n            # Tlat\n            if temp_meta[idx][1] == [] and interval[1] == 0:\n                interval[1] += 1\n                Tlat_head = idx\n            elif temp_meta[idx][1] == [] and interval[1] != 0:\n                interval[1] += 1\n            elif temp_meta[idx][1] != [] and interval[1] != 0:\n                front = float(temp_meta[Tlat_head-1][1][0][0])+float(temp_meta[Tlat_head-1][1][0][2]+"."+temp_meta[Tlat_head-1][1][0][4])/60.\n                rear = float(temp_meta[idx][1][0][0])+float(temp_meta[idx][1][0][2]+"."+temp_meta[idx][1][0][4])/60.\n                gap = rear - front\n                interval_gap = gap / interval[1]\n                for i in range(int(interval[1])) :\n                    value = front+interval_gap*(i+1)\n                    first = math.floor(value)\n                    second = math.floor((value-first)*60)\n                    third = math.floor(((value-first)*60-second)*100)\n                    Tlat = [(str(first), \'°\', str(second), \'.\', str(third))]\n                    temp_meta[Tlat_head+i][1] = Tlat\n                interval[1] = 0\n\n            # Tlon\n            if temp_meta[idx][2] == [] and interval[2] == 0:\n                interval[2] += 1\n                Tlon_head = idx\n            elif temp_meta[idx][2] == [] and interval[2] != 0:\n                interval[2] += 1\n            elif temp_meta[idx][2] != [] and interval[2] != 0:\n                front = float(temp_meta[Tlon_head - 1][2][0][0]) + \\\n                        float(temp_meta[Tlon_head - 1][2][0][2] + "." + temp_meta[Tlon_head - 1][2][0][4]) / 60.\n                rear = float(temp_meta[idx][2][0][0]) + \\\n                       float(temp_meta[idx][2][0][2] + "." + temp_meta[idx][2][0][4]) / 60.\n                gap = rear - front\n                interval_gap = gap / interval[2]\n                for i in range(int(interval[2])):\n                    value = front + interval_gap * (i + 1)\n                    first = math.floor(value)\n                    second = math.floor((value - first) * 60)\n                    third = math.floor(((value - first) * 60 - second) * 100)\n                    Tlat = [(str(first), \'°\', str(second), \'.\', str(third))]\n                    temp_meta[Tlon_head + i][2] = Tlat\n                interval[2] = 0\n\n            # Alon\n            if temp_meta[idx][4] == [] and interval[4] == 0:\n                interval[4] += 1\n                Alon_head = idx\n            elif temp_meta[idx][4] == [] and interval[4] != 0:\n                interval[4] += 1\n            elif temp_meta[idx][4] != [] and interval[4] != 0:\n                front = float(temp_meta[Tlon_head - 1][4][0][0]) + \\\n                        float(temp_meta[Tlon_head - 1][4][0][2] + "." + temp_meta[Tlon_head - 1][4][0][4]) / 60.\n                rear = float(temp_meta[idx][4][0][0]) + \\\n                        float(temp_meta[idx][4][0][2] + "." + temp_meta[idx][4][0][4]) / 60.\n                gap = rear - front\n                interval_gap = gap / interval[4]\n                for i in range(int(interval[4])):\n                    value = front + interval_gap * (i + 1)\n                    first = math.floor(value)\n                    second = math.floor((value - first) * 60)\n                    third = math.floor(((value - first) * 60 - second) * 100)\n                    Alon = [(str(first), \'°\', str(second), \'.\', str(third))]\n                    temp_meta[Alon_head + i][4] = Alon\n                interval[4] = 0\n\n            # Alat\n            if temp_meta[idx][5] == [] and interval[5] == 0:\n                interval[5] += 1\n                Alat_head = idx\n            elif temp_meta[idx][5] == [] and interval[5] != 0:\n                interval[5] += 1\n            elif temp_meta[idx][5] != [] and interval[5] != 0:\n                front = float(temp_meta[Tlon_head - 1][5][0][0]) + \\\n                        float(temp_meta[Tlon_head - 1][5][0][2] + "." + temp_meta[Tlon_head - 1][5][0][4]) / 60.\n                rear = float(temp_meta[idx][5][0][0]) + \\\n                        float(temp_meta[idx][5][0][2] + "." + temp_meta[idx][5][0][4]) / 60.\n                gap = rear - front\n                interval_gap = gap / interval[5]\n                for i in range(int(interval[5])):\n                    value = front + interval_gap * (i + 1)\n                    first = math.floor(value)\n                    second = math.floor((value - first) * 60)\n                    third = math.floor(((value - first) * 60 - second) * 100)\n                    Alat = [(str(first), \'°\', str(second), \'.\', str(third))]\n                    temp_meta[Alat_head + i][5] = Alat\n                interval[5] = 0\n\n            # Az\n            if temp_meta[idx][6] == [] and interval[6] == 0:\n                interval[6] += 1\n                Az_head = idx\n            elif temp_meta[idx][6] == [] and interval[6] != 0:\n                interval[6] += 1\n            elif temp_meta[idx][6] != [] and interval[6] != 0:\n                front = float(temp_meta[Az_head - 1][6][0][0]) + float(temp_meta[Az_head - 1][6][0][2])/10\n                rear = float(temp_meta[idx][6][0][0]) + float(temp_meta[idx][6][0][2])/10\n                gap = rear - front\n                interval_gap = gap / interval[6]\n                for i in range(int(interval[6])):\n                    value = str(front + interval_gap * (i + 1)).split(".")\n                    first = value[0]\n                    second = value[1]\n                    Az = [(str(first), \'.\', str(second))]\n                    temp_meta[Az_head + i][6] = Az\n                interval[6] = 0\n            # El\n            if temp_meta[idx][7] == [] and interval[7] == 0:\n                interval[7] += 1\n                El_head = idx\n            elif temp_meta[idx][7] == [] and interval[7] != 0:\n                interval[7] += 1\n            elif temp_meta[idx][7] != [] and interval[7] != 0:\n                front = float(temp_meta[El_head - 1][7][0][0]) + float(temp_meta[El_head - 1][7][0][2]) / 10.\n                rear = float(temp_meta[idx][7][0][0]) + float(temp_meta[idx][7][0][2]) / 10.\n                gap = rear - front\n                interval_gap = gap / interval[7]\n                for i in range(int(interval[7])):\n                    value = str(front + interval_gap * (i + 1)).split(".")\n                    first = value[0]\n                    second = value[1]\n                    El = [(str(first), \'.\', str(second))]\n                    print("El : ", El)\n                    temp_meta[El_head + i][7] = El\n                interval[7] = 0\n\n        for inter_idx in range(len(temp_meta)):\n            re_frame_dict = {}\n            re_frame_dict[meta_list[0]] = temp_meta[inter_idx][0]\n            re_frame_dict[meta_list[1]] = str(temp_meta[inter_idx][1][0][0]) + \\\n                                          "°" + str(temp_meta[inter_idx][1][0][2]) + \\\n                                          "." + str(temp_meta[inter_idx][1][0][4]) + "\'"\n            re_frame_dict[meta_list[2]] = str(temp_meta[inter_idx][2][0][0]) + \\\n                                          "°" + str(temp_meta[inter_idx][2][0][2]) + \\\n                                          "." + str(temp_meta[inter_idx][2][0][4]) + "\'"\n            re_frame_dict[meta_list[3]] = temp_meta[inter_idx][3]\n            re_frame_dict[meta_list[4]] = str(temp_meta[inter_idx][4][0][0]) + \\\n                                          "°" + str(temp_meta[inter_idx][4][0][2]) + \\\n                                          "." + str(temp_meta[inter_idx][4][0][4]) + "\'"\n            re_frame_dict[meta_list[5]] = str(temp_meta[inter_idx][5][0][0]) + \\\n                                          "°" + str(temp_meta[inter_idx][5][0][2]) + \\\n                                          "." + str(temp_meta[inter_idx][5][0][4]) + "\'"\n            re_frame_dict[meta_list[6]] = str(temp_meta[inter_idx][6][0][0]) + \\\n                                          "." + str(temp_meta[inter_idx][6][0][2]) + "°"\n            print(inter_idx, temp_meta[inter_idx][7])\n            re_frame_dict[meta_list[7]] = str(temp_meta[inter_idx][7][0][0]) + \\\n                                          "." + str(temp_meta[inter_idx][7][0][2]) + "°"\n            re_frame_dict[meta_list[8]] = str(temp_meta[inter_idx][8][0][0]) + \\\n                                          "-" + str(temp_meta[inter_idx][8][0][1]) + \\\n                                          "-" + str(temp_meta[inter_idx][8][0][2])\n            re_frame_dict[meta_list[9]] = str(temp_meta[inter_idx][9][0][0]) + \\\n                                          ":" + str(temp_meta[inter_idx][9][0][1]) + \\\n                                          ":" + str(temp_meta[inter_idx][9][0][2])\n\n            interpolated_meta.append(re_frame_dict)\n        with open(output, "w", encoding=\'UTF-8-sig\', newline=\'\') as f:\n            writer = csv.DictWriter(f, fieldnames=meta_list)\n            writer.writeheader()\n            for data in interpolated_meta:\n                writer.writerow(data)\n            print("FINISHED.")\n\ni = meta_info()\n# i.geo_info(frame_folder_dir="E:\\\\2021_coastguard\\\\frame\\\\D_frames")\ni.interpolation(input="E:\\\\2021_coastguard\\\\coastguard_git\\\\test_psm8.csv",\n                output="E:\\\\2021_coastguard\\\\coastguard_git\\\\test_psm8_interpolated.csv",\n                interpolation=True)\n'} : exceptions must derive from BaseException
2025-01-09 22:29:26,243 - ERROR: Error while reindenting file {'blob_id': 'a5dc95aaaaeabdda0304e488449edae1b9ae7981', 'path': '/Task1/main.py', 'content_id': 'd3a67e04a27af9bb94aab175cd02b0f026685769', 'language': 'Python', 'length_bytes': 5988, 'detected_licenses': [], 'license_type': 'no_license', 'src_encoding': 'UTF-8', 'is_vendor': False, 'is_generated': False, 'alphanum_fraction': 0.5978193879127502, 'alpha_fraction': 0.5451553463935852, 'num_lines': 175, 'avg_line_length': 26.777143478393555, 'max_line_length': 121, 'content': '#1) Сгенерировать dict() из списка ключей ниже по формуле (key : key* key).\n# \u2028keys = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\u2028ожидаемый результат: {1: 1, 2: 4, 3: 9 …}\u2028\nprint("Task №1")\nmy_dict = {}\nfor i in range(1,11):\n    my_dict[i] = i**2\nprint(my_dict)\nprint("*" * 100)\n\n#2) Сгенерировать массив(list()). Из диапазона чисел от 0 до 100 записать в результирующий массив только четные числа.\u2028\nprint("Task №2")\nmy_list = list(range(0,100,2))\nprint(my_list)\nprint("*" * 100)\n\n#3)Заменить в произвольной строке согласные буквы на гласные. \u2028\n# еще думаю\nprint("Task №3")\nprint("-")\nprint("*" * 100)\n#-\n\n#4)Дан массив чисел.\u2028[10, 11, 2, 3, 5, 8, 23, 11, 2, 5, 76, 43, 2, 32, 76, 3, 10, 0, 1]\u2028\n#4.1) убрать из него повторяющиеся элементы\n#4.2) вывести 3 наибольших числа из исходного массива\n#4.3) вывести индекс минимального элемента массива\n#4.4) вывести исходный массив в обратном порядке\u2028\nprint("Task №4")\nmy_list_num = [10, 11, 2, 3, 5, 8, 23, 11, 2, 5, 76, 43, 2, 32, 76, 3, 10, 0, 1]\n#4.1\ncopy_list_num = my_list_num[:]\nfor num in copy_list_num:\n    if copy_list_num.count(num) > 1:\n        copy_list_num.remove(num)\nprint(copy_list_num)\n#4.2\ncopy_list_num = my_list_num[:]\ncopy_list_num.sort()\nprint(f\'max numbers in list: {copy_list_num[-1]},{copy_list_num[-2]},{copy_list_num[-3]}\')\n#4.3\nprint(my_list_num.index(min(my_list_num)))\n#4.4\nmy_list_num.reverse()\nprint(my_list_num)\nprint("*" * 100)\n\n#5) Найти общие ключи в двух словарях:\u2028\n#dict_one = { ‘a’: 1,\u2028 ‘b’: 2, ‘c’: 3,\u2028 ‘d’: 4 }\n#\u2028dict_two = { ‘a’: 6,\u2028 ‘b’: 7, ‘z’: 20,\u2028 ‘x’: 40 }\u2028\nprint("Task №5")\ndict_one = { \'a\': 1, \'b\': 2, \'c\': 3, \'d\': 4 }\ndict_two = { \'a\': 6, \'b\': 7, \'z\': 20, \'x\': 40}\nfor key in dict_one.keys():\n    if key in dict_two.keys():\n        print(key)\nprint("*" * 100)\n\nprint("Task №6")\n#6)Дан массив из словарей\u2028\ndata = [\n    {\'name\': \'Viktor\', \'city\': \'Kiev\', \'age\': 30 },\n    {\'name\': \'Maksim\', \'city\': \'Dnepr\', \'age\': 20},\n    {\'name\': \'Vladimir\', \'city\': \'Lviv\', \'age\': 32},\n    {\'name\': \'Andrey\', \'city\': \'Kiev\', \'age\': 34},\n    {\'name\': \'Artem\', \'city\': \'Dnepr\', \'age\': 50},\n    {\'name\': \'Dmitriy\', \'city\': \'Lviv\', \'age\': 21}]\n#6.1) отсортировать массив из словарей по значению ключа ‘age\'\u2028\ni = 0\nmax = 0\nwhile i < len(data):\n    j = 0\n    while j < len(data) - 1:\n        if data[j].get(\'age\') > data[j + 1].get(\'age\'):\n            data[j], data[j + 1] = data[j + 1], data[j]\n        j += 1\n    i += 1\n\nfor item in data:\n    print(item)\nprint(\'~\' * 100)\n#6.2) сгруппировать данные по значению ключа \'city\'\u2028\n# "Еще думаю"\n#result = {}\n#for i in range(0, len(data)):\n#    result[data[i].get(\'city\')] [{\'name\':data[i].get(\'name\'), \'age\':data[i].get(\'age\')}]\n#print(result)\nprint("*" * 100)\n\n# 7) У вас есть последовательность строк. Необходимо определить наиболее часто встречающуюся строку в последовательности.\n# Например:\nprint("Task 7")\ndef most_frequent(list_var):\n    max_count = 0\n    dict_max_val = {}\n    for i in range(0, len(list_var)):\n        if list_var.count(list_var[i]) > max_count:\n            max_count = list_var.count(list_var[i])\n\n    for i in range(0, len(list_var)):\n        if list_var.count(list_var[i]) == max_count:\n            dict_max_val.update({list_var[i]: max_count})\n    return dict_max_val\n\nprint(most_frequent([\'aa\',\'aa\', \'bb\', \'bb\', \'bb\']))\nprint("*" * 100)\n\n# 8) Дано целое число. Необходимо подсчитать произведение всех цифр в этом числе, за исключением нулей.\n# Например:\n# Дано число 123405. Результат будет: 1*2*3*4*5=120.\nprint("Task №8")\nnumbrs = 123405\nmult = 1\nwhile numbrs > 0:\n    if numbrs%10:\n        mult *= numbrs%10\n    numbrs = numbrs // 10\nprint(mult)\nprint("*" * 100)\n\n# 9) Есть массив с положительными числами и число n (def some_function(array, n)).\n# Необходимо найти n-ую степень элемента в массиве с индексом n. Если n за границами массива, тогда вернуть -1.\nprint("Task №9")\ndef chek_int_in_input(str):\n    for digit in str:\n        if digit.isdigit():\n            return int(digit)\n        else:\n            return 1\n\ndef some_func(array, n):\n    if n > len(array):\n        return -1\n    for it in range(0, len(array)):\n        if it == n:\n            array[it] *= n\n            break\n    return array\n\narray_positive_num = [1, 2, 3, 4, 5]\ninp_num = chek_int_in_input(input("Enter number:"))\nprint(some_func(array_positive_num, inp_num))\nprint("*" * 100)\n\n# 10) Есть строка со словами и числами, разделенными пробелами (один пробел между словами и/или числами).\n# Слова состоят только из букв. Вам нужно проверить есть ли в исходной строке три слова\xa0подряд.\n# Для примера, в строке "hello 1\xa0one two three\xa015 world" есть три слова подряд.\nprint("Task №10")\nstr =\'hello 1 one two three 15 world\'\nspl_str = str.split(" ")\nstart = end = 0\nwhile end < len(spl_str):\n    if spl_str[end].isalpha():\n        if end - start == 2:\n            print(spl_str[start: end + 1])\n        end +=1\n    else:\n        start = end = end + 1\n'} : exceptions must derive from BaseException
