{"repo_name": "PointMeAtTheDawn/warmachine-images", "repo_url": "https://github.com/PointMeAtTheDawn/warmachine-images", "snapshot_id": "d432e8f580520b3587bc064628e67f064e28a894", "revision_id": "0940e789c7a376ef1e84aadbbae52862cf5f4cc6", "directory_id": "50772276001a163acf84dec03f7d50d59a4527fd", "branch_name": "refs/heads/master", "visit_date": "2021-06-13T09:14:38.806175", "revision_date": "2019-07-15T00:31:16", "committer_date": "2019-07-15T00:31:16", "github_id": 189158827, "star_events_count": 0, "fork_events_count": 0, "gha_license_id": null, "gha_created_at": "2019-05-29T05:51:03", "gha_updated_at": "2019-07-15T00:31:24", "gha_pushed_at": "2021-04-30T20:43:59", "gha_language": "Python", "files": [{"blob_id": "b1ad9cbf2d30c061cf89e7ab62e3c35f313281d8", "path": "/requirements.txt", "content_id": "72b8a382110d164a30b45a6539c880b923b5f1dc", "language": "Text", "length_bytes": 593, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6897132992744446, "alpha_fraction": 0.48566609621047974, "num_lines": 35, "avg_line_length": 15.942856788635254, "max_line_length": 31}, {"blob_id": "c1d7d7801c27dea3ff28cd5cb70d0bd811d25e56", "path": "/convert.py", "content_id": "eae679219a09726a4295b97b955045e7ca752f99", "language": "Python", "length_bytes": 6660, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6288288235664368, "alpha_fraction": 0.5714714527130127, "num_lines": 167, "avg_line_length": 38.88024139404297, "max_line_length": 97, "content": "\"\"\"This converts a cardbundle.pdf (downloaded from Privateer Press) into\n   Tabletop Simulator deck Saved Objects.\"\"\"\n\nimport os\nimport argparse\nimport json\nimport threading\nfrom shutil import copyfile\nimport PIL.ImageOps\nfrom PIL import Image\nimport cloudinary.uploader\nimport cloudinary.api\nfrom pdf2image import convert_from_path\n\ndef parse_images(fronts, backs, raw_page):\n    \"\"\"Chop a page from the PP PDF into its constituent card images.\"\"\"\n    # 400 DPI\n    # fronts.append(raw_page.crop((188, 303, 1185, 1703)))\n    # fronts.append(raw_page.crop((1193, 303, 2190, 1703)))\n    # fronts.append(raw_page.crop((2199, 303, 3196, 1703)))\n    # fronts.append(raw_page.crop((3205, 303, 4201, 1703)))\n    # backs.append(raw_page.crop((188, 1709, 1185, 3106)))\n    # backs.append(raw_page.crop((1193, 1709, 2190, 3106)))\n    # backs.append(raw_page.crop((2199, 1709, 3196, 3106)))\n    # backs.append(raw_page.crop((3205, 1709, 4201, 3106)))\n    # 200 DPI\n    fronts.append(raw_page.crop((94, 151, 592, 852)))\n    fronts.append(raw_page.crop((597, 151, 1095, 852)))\n    fronts.append(raw_page.crop((1099, 151, 1598, 852)))\n    fronts.append(raw_page.crop((1602, 151, 2101, 852)))\n    backs.append(raw_page.crop((94, 855, 592, 1553)))\n    backs.append(raw_page.crop((597, 855, 1095, 1553)))\n    backs.append(raw_page.crop((1099, 855, 1598, 1553)))\n    backs.append(raw_page.crop((1602, 855, 2101, 1553)))\n    # 150 DPI\n    # fronts.append(page.crop((70,114,444,639)))\n    # fronts.append(page.crop((447,114,821,639)))\n    # fronts.append(page.crop((824,114,1198,639)))\n    # fronts.append(page.crop((1202,114,1576,639)))\n    # backs.append(page.crop((70,641,444,1165)))\n    # backs.append(page.crop((447,641,821,1165)))\n    # backs.append(page.crop((824,641,1198,1165)))\n    # backs.append(page.crop((1202,641,1576,1165)))\n\ndef load_config():\n    \"\"\"Load your config\"\"\"\n    with open('config.json') as json_file:\n        data = json.load(json_file)\n        cloudinary.config(\n            cloud_name=data[\"cloud_name\"],\n            api_key=data[\"api_key\"],\n            api_secret=data[\"api_secret\"]\n        )\n        return data[\"width\"], data[\"height\"], data[\"saved_objects_folder\"]\n\ndef image_upload(name, links):\n    \"\"\"Upload a compiled TTS-compatible deck template image into Cloudinary.\"\"\"\n\n    res = cloudinary.uploader.upload(name)\n\n    links[name] = res[\"url\"]\n    os.remove(name)\n    print(links[name])\n\n\ndef package_pages(cards_width, cards_height, fronts, backs, page_count, links):\n    \"\"\"Stitch together card images into a TTS-compatible deck template image\"\"\"\n    pixel_width = 4096//cards_width\n    pixel_height = 4096//cards_height\n    for i in range(page_count):\n        fronts_image = Image.new(\"RGB\", (4096, 4096))\n        backs_image = Image.new(\"RGB\", (4096, 4096))\n\n        for j in range(cards_width * cards_height):\n            if len(fronts) <= i * cards_width * cards_height + j:\n                continue\n            front = fronts[i * cards_width * cards_height + j].resize(\n                (pixel_width, pixel_height), Image.BICUBIC)\n            back = backs[i * cards_width * cards_height + j].resize(\n                (pixel_width, pixel_height), Image.BICUBIC).rotate(180)\n            fronts_image.paste(front, (j % cards_width * pixel_width,\n                                       (j // cards_width) * pixel_height))\n            backs_image.paste(back, (j % cards_width * pixel_width,\n                                     (j // cards_width) * pixel_height))\n\n        fronts_image.save(f\"f-{i}.jpg\")\n        backs_image.save(f\"b-{i}.jpg\")\n        t_1 = threading.Thread(\n            target=image_upload, args=(f\"f-{i}.jpg\", links)\n        )\n        t_1.start()\n        t_2 = threading.Thread(\n            target=image_upload, args=(f\"b-{i}.jpg\", links)\n        )\n        t_2.start()\n        t_1.join()\n        t_2.join()\n\ndef write_deck(deck_json, args, saved_objects_folder, links, num):\n    \"\"\"Craft the JSON for your final TTS deck Saved Object\"\"\"\n    name = args.name + str(num)\n    deck_json = deck_json.replace(\"DeckName\", name)\n    deck_json = deck_json.replace(\"FrontImageURL\", links[f\"f-{num}.jpg\"])\n    deck_json = deck_json.replace(\"BackImageURL\", links[f\"b-{num}.jpg\"])\n    deck_json = deck_json.replace(\"ReplaceGUID\", f\"{name}C\")\n    deck_json = deck_json.replace(\"ReplaceGUID2\", f\"{name}D\")\n    with open(saved_objects_folder + name + \".json\", \"w\") as deck:\n        deck.write(deck_json)\n    copyfile(\"warmahordes.png\", saved_objects_folder + name + \".png\")\n\ndef parse_arguments():\n    \"\"\"Command line arg parse\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Convert Privateer Press card pdfs to Tabletop Simulator saved deck objects.\"\n    )\n    parser.add_argument(\n        \"-name\",\n        type=str,\n        help=\"your deck name - possibly the faction you are converting\",\n    )\n    return parser.parse_args()\n\ndef convert():\n    \"\"\"This converts a cardbundle.pdf (downloaded from Privateer Press) into\n    Tabletop Simulator deck Saved Objects.\"\"\"\n    args = parse_arguments()\n    width, height, saved_objects_folder = load_config()\n    if args.name is None:\n        args.name = \"Warmachine\"\n    print(\"Naming decks: \" + args.name + \"X\")\n\n    # Strip out the card images from the Privateer Press pdfs.\n    card_fronts = []\n    card_backs = []\n    infile = \"cardbundle.pdf\"\n    pages = convert_from_path(infile, 200, output_folder=\"pdf_parts\")\n    for page in pages:\n        parse_images(card_fronts, card_backs, page)\n    print(\"Parsing cardbundle.pdf complete.\")\n\n    # But we don't want the blank white cards.\n    # I'd rather do a .filter, but I'm concerned a stray pixel would put them outta sync.\n    filtered_fronts = []\n    filtered_backs = []\n    for i, card in enumerate(card_fronts):\n        if PIL.ImageOps.invert(card).getbbox():\n            filtered_fronts.append(card)\n            filtered_backs.append(card_backs[i])\n    print(\"Stripping out blank cards complete.\")\n\n    # Collate the cards into the image format Tabletop Simulator requires.\n    links = {}\n    deck_count = len(card_fronts) // (width*height) + 1\n    package_pages(width, height, filtered_fronts, filtered_backs, deck_count, links)\n    print(\"Packaging cards into TTS deck template images and uploading to Cloudinary complete.\")\n\n    # And let's shove em all in your Saved Objects folder :)\n    deck_json = \"\"\n    with open(\"decktemplate.json\", \"r\") as deck_template:\n        deck_json = deck_template.read()\n    for i in range(deck_count):\n        write_deck(deck_json, args, saved_objects_folder, links, i)\n    print(\"Writing deck jsons into Saved Object folder complete.\")\n\n\nif __name__ == \"__main__\":\n    convert()\n"}, {"blob_id": "d0fca037ff8a57c813185ed1e008825b7e843cf1", "path": "/README.md", "content_id": "1fa6972f317a3b109bb71a05a9cd918536b17f70", "language": "Markdown", "length_bytes": 1272, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7881889939308167, "alpha_fraction": 0.7842519879341125, "num_lines": 13, "avg_line_length": 96.76923370361328, "max_line_length": 752}], "num_files": 3}
{"repo_name": "androiddevnotesforks/github-scraper", "repo_url": "https://github.com/androiddevnotesforks/github-scraper", "snapshot_id": "a993747c86e19ee31d12ada2db73fc5877a44284", "revision_id": "b4c88180f2a3dd3b622d60a04487057aef5b8a3d", "directory_id": "0fbd2c89bb83bbbe81712d9bf4e72bfdd1468517", "branch_name": "refs/heads/master", "visit_date": "2023-05-28T12:08:14.278275", "revision_date": "2021-06-05T13:08:43", "committer_date": "2021-06-05T13:08:43", "github_id": 338650736, "star_events_count": 3, "fork_events_count": 0, "gha_license_id": null, "gha_created_at": "2021-02-13T19:18:36", "gha_updated_at": "2021-05-31T13:39:37", "gha_pushed_at": "2021-06-05T16:37:00", "gha_language": "Python", "files": [{"blob_id": "fc95e8e832500b68c178027c311861a400632a17", "path": "/README.md", "content_id": "758a3400ff369679a35973d2fe67cf432dfa08e9", "language": "Markdown", "length_bytes": 3705, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7360323667526245, "alpha_fraction": 0.7338731288909912, "num_lines": 65, "avg_line_length": 56.0, "max_line_length": 561}, {"blob_id": "2c47f3be8be9e621401c83498f7008aa0dfb3a4a", "path": "/github_scraper.py", "content_id": "c48417823772908625d519ebdf5b957f59e359fc", "language": "Python", "length_bytes": 20933, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5598815083503723, "alpha_fraction": 0.5592127442359924, "num_lines": 541, "avg_line_length": 37.69316101074219, "max_line_length": 88, "content": "\"\"\"Scrape GitHub data for organizational accounts.\"\"\"\n\nimport argparse\nimport asyncio\nimport csv\nimport json\nimport sys\nimport time\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Tuple\n\nimport aiohttp\nimport networkx as nx\n\n\nclass GithubScraper():\n    \"\"\"Scrape information about organizational Github accounts.\n\n    Use Github API key and user name to make requests to Github API.\n    Create spreadsheets named after data type and date.\n\n    Attributes:\n        orgs (List[str]): List of organizational Github accounts to scrape\n        session (aiohttp.ClientSession): Session using Github user name and API token\n    \"\"\"\n\n    def __init__(self, organizations: List[str],\n                 session: aiohttp.ClientSession) -> None:\n        \"\"\"Instantiate object.\"\"\"\n        self.orgs = organizations\n        self.session = session\n        # Members and repositories of listed organizations. Instantiated as empty dict\n        # and only loaded if user selects operation that needs this list.\n        # Saves API calls.\n        self.members: Dict[str, List[str]] = {}\n        self.repos: List[Dict[str, Any]] = []\n        # Directory to store scraped data with timestamp\n        self.data_directory: Path = Path(\n            Path.cwd(), 'data', time.strftime('%Y-%m-%d_%H-%M-%S')\n        )\n        Path(self.data_directory).mkdir()\n\n    async def get_members(self) -> Dict[str, List[str]]:\n        \"\"\"Get list of members of specified orgs.\n\n        Returns:\n            Dict[str, List[str]]: Keys are orgs, values list of members\n        \"\"\"\n        print(\"Collecting members of specified organizations...\")\n        members: Dict[str, List[str]] = {}\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.orgs:\n            url = f\"https://api.github.com/orgs/{org}/members\"\n            tasks.append(asyncio.create_task(self.call_api(url, organization=org)))\n        json_org_members: List[Dict[str, Any]] = await self.load_json(tasks)\n        # Extract names of org members from JSON data\n        for org in self.orgs:\n            members[org] = []\n        for member in json_org_members:\n            members[member[\"organization\"]].append(member['login'])\n        return members\n\n    async def load_json(self, tasks: List[asyncio.Task[Any]]) -> List[Dict[str, Any]]:\n        \"\"\"Execute tasks with asyncio.wait() to make API calls.\n\n        Args:\n            tasks (List[asyncio.Task[Any]]): List of awaitable tasks to execute\n\n        Returns:\n            List[Dict[str, Any]]: Full JSON returned by API\n        \"\"\"\n        full_json: List[Dict[str, Any]] = []\n        done, pending = await asyncio.wait(\n            tasks, return_when=\"ALL_COMPLETED\"\n        )\n        for task in done:\n            try:\n                full_json.extend(await task)\n            except aiohttp.ContentTypeError:\n                # If repository is empty, pass\n                pass\n        return full_json\n\n    async def call_api(self, url: str, **added_fields: str) -> List[Dict[str, Any]]:\n        \"\"\"Load json file using requests.\n\n        Makes API calls and returns JSON results.\n\n        Args:\n            url (str): Github API URL to load as JSON\n            **added_fields (str): Additional information that will be added to each item\n                                  in the JSON data\n\n        Returns:\n            List[Dict[str, Any]]: Github URL loaded as JSON\n        \"\"\"\n        page: int = 1\n        json_data: List[Dict[str, Any]] = []\n        # Requesting user info doesn't support pagination and returns dict, not list\n        if url.split(\"/\")[-2] == 'users':\n            async with self.session.get(f\"{url}?per_page=100\") as resp:\n                member_json: Dict[str, Any] = await resp.json()\n                for key, value in added_fields.items():\n                    member_json[key] = value\n                json_data.append(member_json)\n            return json_data\n        # Other API calls return lists and should paginate\n        while True:\n            async with self.session.get(f\"{url}?per_page=100&page={str(page)}\") as resp:\n                json_page: List[Dict[str, Any]] = await resp.json()\n                if json_page == []:\n                    break\n                for item in json_page:\n                    for key, value in added_fields.items():\n                        item[key] = value\n                json_data.extend(json_page)\n                page += 1\n        return json_data\n\n    def generate_csv(self, file_name: str, json_list: List[Dict[str, Any]],\n                     columns_list: List) -> None:\n        \"\"\"Write CSV file.\n\n        Args:\n            file_name (str): Name of the CSV file\n            json_list (List[Dict[str, Any]]): JSON data to turn into CSV\n            columns_list (List): List of columns that represent relevant fields\n                                 in the JSON data\n        \"\"\"\n        with open(\n                Path(self.data_directory, file_name),\n                'a+',\n                encoding='utf-8'\n        ) as file:\n            csv_file = csv.DictWriter(\n                file,\n                fieldnames=columns_list,\n                extrasaction=\"ignore\"\n            )\n            csv_file.writeheader()\n            for item in json_list:\n                csv_file.writerow(item)\n        print(\n            f\"- file saved as {Path('data', self.data_directory.name, file_name)}\"\n        )\n\n    async def get_org_repos(self) -> List[Dict[str, Any]]:\n        \"\"\"Create list of the organizations' repositories.\"\"\"\n        print(\"Scraping repositories\")\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.orgs:\n            url = f\"https://api.github.com/orgs/{org}/repos\"\n            tasks.append(asyncio.create_task(self.call_api(url, organization=org)))\n        return await self.load_json(tasks)\n\n    async def create_org_repo_csv(self) -> None:\n        \"\"\"Write a CSV file with information about orgs' repositories.\"\"\"\n        # Create list of items that should appear as columns in the CSV\n        table_columns: List[str] = [\n            'organization',\n            'name',\n            'full_name',\n            'stargazers_count',\n            'language',\n            'created_at',\n            'updated_at',\n            'homepage',\n            'fork',\n            'description'\n        ]\n        self.generate_csv('org_repositories.csv', self.repos, table_columns)\n\n    async def get_repo_contributors(self) -> None:\n        \"\"\"Create list of contributors to the organizations' repositories.\"\"\"\n        print(\"Scraping contributors\")\n        json_contributors_all = []\n        graph = nx.DiGraph()\n        table_columns: List[str] = [\n            'organization',\n            'repository',\n            'login',\n            'contributions',\n            'html_url',\n            'url'\n        ]\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.orgs:\n            for repo in self.repos:\n                url = f\"https://api.github.com/repos/{org}/{repo['name']}/contributors\"\n                tasks.append(\n                    asyncio.create_task(\n                        self.call_api(url, organization=org, repository=repo['name'])\n                    )\n                )\n        json_contributors_all = await self.load_json(tasks)\n        self.generate_csv('contributor_list.csv', json_contributors_all, table_columns)\n        for contributor in json_contributors_all:\n            graph.add_node(\n                contributor['repository'], organization=contributor['organization']\n            )\n            graph.add_edge(\n                contributor['login'],\n                contributor['repository'],\n                organization=contributor['organization']\n            )\n        nx.write_gexf(\n            graph,\n            Path(self.data_directory, 'contributor_network.gexf')\n        )\n        print(\n            \"- file saved as \"\n            f\"{Path('data', self.data_directory.name, 'contributor_network.gexf')}\"\n        )\n\n    async def get_members_repos(self) -> None:\n        \"\"\"Create list of all the members of an organization and their repositories.\"\"\"\n        print(\"Getting repositories of all members.\")\n        json_members_repos: List[Dict[str, Any]] = []\n        table_columns: List[str] = [\n            'organization',\n            'user',\n            'full_name',\n            'fork',\n            'stargazers_count',\n            'forks_count',\n            'language',\n            'description'\n        ]\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.members:\n            for member in self.members[org]:\n                url = f\"https://api.github.com/users/{member}/repos\"\n                tasks.append(\n                    asyncio.create_task(\n                        self.call_api(url, organization=org, user=member)\n                    )\n                )\n        json_members_repos = await self.load_json(tasks)\n        self.generate_csv('members_repositories.csv',\n                          json_members_repos, table_columns)\n\n    async def get_members_info(self) -> None:\n        \"\"\"Gather information about the organizations' members.\"\"\"\n        print(\"Getting user information of all members.\")\n        table_columns: List[str] = [\n            'organization',\n            'login',\n            'name',\n            'url',\n            'type',\n            'company',\n            'blog',\n            'location'\n        ]\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.orgs:\n            for member in self.members[org]:\n                url = f\"https://api.github.com/users/{member}\"\n                tasks.append(asyncio.create_task(\n                    self.call_api(url, organization=org))\n                )\n        json_members_info: List[Dict[str, Any]] = await self.load_json(tasks)\n        self.generate_csv('members_info.csv', json_members_info, table_columns)\n\n    async def get_starred_repos(self) -> None:\n        \"\"\"Create list of all the repositories starred by organizations' members.\"\"\"\n        print(\"Getting repositories starred by members.\")\n        json_starred_repos_all: List[Dict[str, Any]] = []\n        table_columns: List[str] = [\n            'organization',\n            'user',\n            'full_name',\n            'html_url',\n            'language',\n            'description'\n        ]\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.members:\n            for member in self.members[org]:\n                url = f\"https://api.github.com/users/{member}/starred\"\n                tasks.append(asyncio.create_task(\n                    self.call_api(url, organization=org, user=member))\n                )\n        json_starred_repos_all = await self.load_json(tasks)\n        self.generate_csv('starred_repositories.csv',\n                          json_starred_repos_all, table_columns)\n\n    async def generate_follower_network(self) -> None:\n        \"\"\"Create full or narrow follower networks of organizations' members.\n\n        Get every user following the members of organizations (followers)\n        and the users they are following themselves (following). Then generate two\n        directed graphs with NetworkX. Only includes members of specified organizations\n        if in narrow follower network.\n        \"\"\"\n        print('Generating follower networks')\n        # Create graph dict and add self.members as nodes\n        graph_full = nx.DiGraph()\n        graph_narrow = nx.DiGraph()\n        for org in self.orgs:\n            for member in self.members[org]:\n                graph_full.add_node(member, organization=org)\n                graph_narrow.add_node(member, organization=org)\n\n        # Get followers and following for each member and build graph\n        tasks_followers: List[asyncio.Task[Any]] = []\n        tasks_following: List[asyncio.Task[Any]] = []\n        for org in self.members:\n            for member in self.members[org]:\n                url_followers = f\"https://api.github.com/users/{member}/followers\"\n                tasks_followers.append(\n                    asyncio.create_task(\n                        self.call_api(url_followers, follows=member, original_org=org))\n                )\n                url_following = f\"https://api.github.com/users/{member}/following\"\n                tasks_following.append(\n                    asyncio.create_task(\n                        self.call_api(\n                            url_following, followed_by=member, original_org=org)\n                    )\n                )\n        json_followers = await self.load_json(tasks_followers)\n        json_following = await self.load_json(tasks_following)\n        # Build full and narrow graphs\n        for follower in json_followers:\n            graph_full.add_edge(\n                follower['login'],\n                follower['follows'],\n                organization=follower['original_org']\n            )\n            if follower['login'] in self.members[follower['original_org']]:\n                graph_narrow.add_edge(\n                    follower['login'],\n                    follower['follows'],\n                    organization=follower['original_org'])\n        for following in json_following:\n            graph_full.add_edge(\n                following['followed_by'],\n                following['login'],\n                organization=following['original_org'])\n            if following['login'] in self.members[following['original_org']]:\n                graph_narrow.add_edge(\n                    following['followed_by'],\n                    following['login'],\n                    organization=following['original_org'])\n        # Write graphs and save files\n        nx.write_gexf(\n            graph_full,\n            Path(self.data_directory, \"full-follower-network.gexf\"))\n        nx.write_gexf(\n            graph_narrow,\n            Path(self.data_directory, \"narrow-follower-network.gexf\"))\n        print(\n            f\"- files saved in {Path('data', self.data_directory.name)} as \"\n            \"full-follower-network.gexf and narrow-follower-network.gexf\"\n        )\n\n    async def generate_memberships_network(self) -> None:\n        \"\"\"Take all the members of the organizations and generate a directed graph.\n\n        This shows creates a network with the organizational memberships.\n        \"\"\"\n        print(\"Generating network of memberships.\")\n        graph = nx.DiGraph()\n        tasks: List[asyncio.Task[Any]] = []\n        for org in self.members:\n            for member in self.members[org]:\n                url = f\"https://api.github.com/users/{member}/orgs\"\n                tasks.append(asyncio.create_task(\n                    self.call_api(\n                        url, organization=org, scraped_org_member=member))\n                )\n        json_org_memberships = await self.load_json(tasks)\n        for membership in json_org_memberships:\n            graph.add_node(membership['scraped_org_member'], node_type='user')\n            graph.add_edge(\n                membership['scraped_org_member'],\n                membership['login'],  # name of organization user is member of\n                node_type='organization')\n        nx.write_gexf(\n            graph,\n            Path(self.data_directory, 'membership_network.gexf')\n        )\n        print(\n            \"- file saved as \"\n            f\"{Path('data', self.data_directory.name, 'membership_network.gexf')}\"\n        )\n\n\ndef read_config() -> Tuple[str, str]:\n    \"\"\"Read config file.\n\n    Returns:\n        Tuple[str, str]: Github user name and API token\n\n    Raises:\n        KeyError: If config file is empty\n    \"\"\"\n    try:\n        with open(Path(Path.cwd(), 'config.json'), 'r', encoding='utf-8') as file:\n            config = json.load(file)\n            user: str = config['user_name']\n            api_token: str = config['api_token']\n            if user == \"\" or api_token == \"\":\n                raise KeyError\n            else:\n                return user, api_token\n    except (FileNotFoundError, KeyError):\n        sys.exit(\"Failed to read Github user name and/or API token. \"\n                 \"Please add them to the config.json file.\")\n\n\ndef read_organizations() -> List[str]:\n    \"\"\"Read list of organizations from file.\n\n    Returns:\n        List[str]: List of names of organizational Github accounts\n    \"\"\"\n    orgs: List[str] = []\n    with open(Path(Path.cwd(), 'organizations.csv'), 'r', encoding=\"utf-8\") as file:\n        reader = csv.DictReader(file)\n        for row in reader:\n            orgs.append(row['github_org_name'])\n    if not orgs:\n        sys.exit(\"No organizations to scrape found in organizations.csv. \"\n                 \"Please add the names of the organizations you want to scrape \"\n                 \"in the column 'github_org_name' (one name per row).\")\n    return orgs\n\n\ndef parse_args() -> Dict[str, bool]:\n    \"\"\"Parse arguments.\n\n    We use the 'dest' value to map args with functions/methods. This way, we\n    can use getattr(object, dest)() and avoid long if...then list in main().\n\n    Returns:\n        Dict[str, bool]: Result of vars(parse_args())\n    \"\"\"\n    argparser = argparse.ArgumentParser(\n        description=\"Scrape organizational accounts on Github.\"\n    )\n    argparser.add_argument(\n        \"--all\",\n        \"-a\",\n        action=\"store_true\",\n        help=\"scrape all the information listed below\"\n    )\n    argparser.add_argument(\n        \"--repos\",\n        \"-r\",\n        action='store_true',\n        dest=\"create_org_repo_csv\",\n        help=\"scrape the organizations' repositories (CSV)\"\n    )\n    argparser.add_argument(\n        \"--contributors\",\n        \"-c\",\n        action=\"store_true\",\n        dest=\"get_repo_contributors\",\n        help=\"scrape contributors of the organizations' repositories (CSV and GEXF)\"\n    )\n    argparser.add_argument(\n        \"--member_repos\",\n        \"-mr\",\n        action=\"store_true\",\n        dest=\"get_members_repos\",\n        help=\"scrape all repositories owned by the members of the organizations (CSV)\"\n    )\n    argparser.add_argument(\n        \"--member_infos\",\n        \"-mi\",\n        action=\"store_true\",\n        dest=\"get_members_info\",\n        help=\"scrape information about each member of the organizations (CSV)\"\n    )\n    argparser.add_argument(\n        \"--starred\",\n        \"-s\",\n        action=\"store_true\",\n        dest=\"get_starred_repos\",\n        help=\"scrape all repositories starred by the members of the organizations (CSV)\"\n    )\n    argparser.add_argument(\n        \"--followers\",\n        \"-f\",\n        action=\"store_true\",\n        dest=\"generate_follower_network\",\n        help=\"generate a follower network. Creates full and narrow network graph, the \"\n             \"latter only shows how scraped organizations are networked among each \"\n             \"other (two GEXF files)\"\n    )\n    argparser.add_argument(\n        \"--memberships\",\n        \"-m\",\n        action=\"store_true\",\n        dest=\"generate_memberships_network\",\n        help=\"scrape all organizational memberships of org members (GEXF)\"\n    )\n    args: Dict[str, bool] = vars(argparser.parse_args())\n    return args\n\n\nasync def main() -> None:\n    \"\"\"Set up GithubScraper object.\"\"\"\n    args: Dict[str, bool] = parse_args()\n    if not any(args.values()):\n        sys.exit(\"You need to provide at least one argument. \"\n                 \"For usage, call: github_scraper -h\")\n    user, api_token = read_config()\n    organizations = read_organizations()\n    # To avoid unnecessary API calls, only get org members and repos if needed\n    require_members = ['get_members_repos', 'get_members_info', 'get_starred_repos',\n                       'generate_follower_network', 'generate_memberships_network']\n    require_repos = ['create_org_repo_csv', 'get_repo_contributors']\n    # Start aiohttp session\n    auth = aiohttp.BasicAuth(user, api_token)\n    async with aiohttp.ClientSession(auth=auth) as session:\n        github_scraper = GithubScraper(organizations, session)\n        # If --all was provided, simply run everything\n        if args['all']:\n            github_scraper.members = await github_scraper.get_members()\n            github_scraper.repos = await github_scraper.get_org_repos()\n            for arg in args:\n                if arg != 'all':\n                    await getattr(github_scraper, arg)()\n        else:\n            # Check args provided, get members/repos if necessary, call related methods\n            called_args = [arg for arg, value in args.items() if value]\n            if any(arg for arg in called_args if arg in require_members):\n                github_scraper.members = await github_scraper.get_members()\n            if any(arg for arg in called_args if arg in require_repos):\n                github_scraper.repos = await github_scraper.get_org_repos()\n            for arg in called_args:\n                await getattr(github_scraper, arg)()\n\n\nif __name__ == \"__main__\":\n    if sys.platform == 'win32':\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n    asyncio.run(main())\n"}], "num_files": 2}
{"repo_name": "smellycats/SX-CarRecgServer", "repo_url": "https://github.com/smellycats/SX-CarRecgServer", "snapshot_id": "79640c297195acc74e84c2b08df45ce06c9ba060", "revision_id": "3bf19e76f39f60c9a5ba39269dadbad265516056", "directory_id": "aa9d4afb1eb52fcdabc99d8b9db2fb240b9dd161", "branch_name": "refs/heads/master", "visit_date": "2021-01-20T05:31:17.651240", "revision_date": "2015-10-11T15:36:44", "committer_date": "2015-10-11T15:36:44", "github_id": 38525081, "star_events_count": 0, "fork_events_count": 1, "gha_license_id": null, "gha_created_at": "2015-07-04T06:58:28", "gha_updated_at": "2015-07-04T07:00:14", "gha_pushed_at": "2015-10-11T15:36:44", "gha_language": "Python", "files": [{"blob_id": "ab72a4b7f66d3a1679f6e5cb1e87814a03205b9d", "path": "/run.py", "content_id": "2a37c691c9984d6e58c46639e1dd9f01f0a96461", "language": "Python", "length_bytes": 404, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6138613820075989, "alpha_fraction": 0.5990098714828491, "num_lines": 14, "avg_line_length": 27.85714340209961, "max_line_length": 64, "content": "from car_recg import app\nfrom car_recg.recg_ser import RecgServer\nfrom ini_conf import MyIni\n\nif __name__ == '__main__':\n    rs = RecgServer()\n    rs.main()\n    my_ini = MyIni()\n    sys_ini = my_ini.get_sys_conf()\n    app.config['THREADS'] = sys_ini['threads']\n    app.config['MAXSIZE'] = sys_ini['threads'] * 16\n    app.run(host='0.0.0.0', port=sys_ini['port'], threaded=True)\n    del rs\n    del my_ini\n"}, {"blob_id": "f9194bb12d5cc33adf2af50a9c98983377bfea7e", "path": "/car_recg/config.py", "content_id": "599732078eb06b7b2a9daf5d9a2810b72e5e7d9e", "language": "Python", "length_bytes": 1208, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5938123464584351, "alpha_fraction": 0.5698602795600891, "num_lines": 53, "avg_line_length": 17.90566062927246, "max_line_length": 69, "content": "# -*- coding: utf-8 -*-\nimport Queue\n\n\nclass Config(object):\n    # \u5bc6\u7801 string\n    SECRET_KEY = 'hellokitty'\n    # \u670d\u52a1\u5668\u540d\u79f0 string\n    HEADER_SERVER = 'SX-CarRecgServer'\n    # \u52a0\u5bc6\u6b21\u6570 int\n    ROUNDS = 123456\n    # token\u751f\u5b58\u5468\u671f\uff0c\u9ed8\u8ba41\u5c0f\u65f6 int\n    EXPIRES = 7200\n    # \u6570\u636e\u5e93\u8fde\u63a5 string\n    SQLALCHEMY_DATABASE_URI = 'mysql://root:root@127.0.0.1/hbc_store'\n    # \u6570\u636e\u5e93\u8fde\u63a5\u7ed1\u5b9a dict\n    SQLALCHEMY_BINDS = {}\n    # \u7528\u6237\u6743\u9650\u8303\u56f4 dict\n    SCOPE_USER = {}\n    # \u767d\u540d\u5355\u542f\u7528 bool\n    WHITE_LIST_OPEN = True\n    # \u767d\u540d\u5355\u5217\u8868 set\n    WHITE_LIST = set()\n    # \u5904\u7406\u7ebf\u7a0b\u6570 int\n    THREADS = 4\n    # \u5141\u8bb8\u6700\u5927\u6570\u961f\u5217\u4e3a\u7ebf\u7a0b\u657016\u500d int\n    MAXSIZE = THREADS * 16\n    # \u56fe\u7247\u4e0b\u8f7d\u6587\u4ef6\u5939 string\n    IMG_PATH = 'img'\n    # \u56fe\u7247\u622a\u53d6\u6587\u4ef6\u5939 string\n    CROP_PATH = 'crop'\n    # \u8d85\u65f6 int\n    TIMEOUT = 5\n    # \u8bc6\u522b\u4f18\u5148\u961f\u5217 object\n    RECGQUE = Queue.PriorityQueue()\n    # \u9000\u51fa\u6807\u8bb0 bool\n    IS_QUIT = False\n    # \u7528\u6237\u5b57\u5178 dict\n    USER = {}\n    # \u4e0a\u4f20\u6587\u4ef6\u4fdd\u5b58\u8def\u5f84 string\n    UPLOAD_PATH = 'upload'\n\n\nclass Develop(Config):\n    DEBUG = True\n\n\nclass Production(Config):\n    DEBUG = False\n\n\nclass Testing(Config):\n    TESTING = True\n"}, {"blob_id": "a86f1255ebca9673b94ccbc5613acd9ad3e0a42e", "path": "/car_recg/views.py", "content_id": "ac75ddfe82f4da2667af81fe12be94049ea340aa", "language": "Python", "length_bytes": 5750, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5586342215538025, "alpha_fraction": 0.5402216911315918, "num_lines": 176, "avg_line_length": 30.784090042114258, "max_line_length": 134, "content": "# -*- coding: utf-8 -*-\nimport os\nimport Queue\nimport random\nfrom functools import wraps\n\nimport arrow\nfrom flask import g, request\nfrom flask_restful import reqparse, Resource\nfrom passlib.hash import sha256_crypt\nfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializer\n\nfrom car_recg import app, db, api, auth, limiter, logger, access_logger\nfrom models import Users, Scope\nimport helper\n\n\ndef verify_addr(f):\n    \"\"\"IP\u5730\u5740\u767d\u540d\u5355\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not app.config['WHITE_LIST_OPEN'] or request.remote_addr == '127.0.0.1' or request.remote_addr in app.config['WHITE_LIST']:\n            pass\n        else:\n            return {'status': '403.6',\n                    'message': u'\u7981\u6b62\u8bbf\u95ee:\u5ba2\u6237\u7aef\u7684 IP \u5730\u5740\u88ab\u62d2\u7edd'}, 403\n        return f(*args, **kwargs)\n    return decorated_function\n\n\n@auth.verify_password\ndef verify_password(username, password):\n    if username.lower() == 'admin':\n        user = Users.query.filter_by(username='admin').first()\n    else:\n        return False\n    if user:\n        return sha256_crypt.verify(password, user.password)\n    return False\n\n\ndef verify_token(f):\n    \"\"\"token\u9a8c\u8bc1\u88c5\u9970\u5668\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not request.headers.get('Access-Token'):\n            return {'status': '401.6', 'message': 'missing token header'}, 401\n        token_result = verify_auth_token(request.headers['Access-Token'],\n                                         app.config['SECRET_KEY'])\n        if not token_result:\n            return {'status': '401.7', 'message': 'invalid token'}, 401\n        elif token_result == 'expired':\n            return {'status': '401.8', 'message': 'token expired'}, 401\n        g.uid = token_result['uid']\n        g.scope = set(token_result['scope'])\n\n        return f(*args, **kwargs)\n    return decorated_function\n\n\ndef verify_scope(scope):\n    def scope(f):\n        \"\"\"\u6743\u9650\u8303\u56f4\u9a8c\u8bc1\u88c5\u9970\u5668\"\"\"\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if 'all' in g.scope or scope in g.scope:\n                return f(*args, **kwargs)\n            else:\n                return {}, 405\n        return decorated_function\n    return scope\n\n\nclass Index(Resource):\n\n    def get(self):\n        return {\n            'user_url': '%suser{/user_id}' % (request.url_root),\n            'scope_url': '%suser/scope' % (request.url_root),\n            'token_url': '%stoken' % (request.url_root),\n            'recg_url': '%sv1/recg' % (request.url_root),\n            'uploadrecg_url': '%sv1/uploadrecg' % (request.url_root),\n            'state_url': '%sv1/state' % (request.url_root)\n        }, 200, {'Cache-Control': 'public, max-age=60, s-maxage=60'}\n\n\nclass RecgListApiV1(Resource):\n\n    def post(self):\n        parser = reqparse.RequestParser()\n\n        parser.add_argument('imgurl', type=unicode, required=True,\n                            help='A jpg url is require', location='json')\n        parser.add_argument('coord', type=list, required=True,\n                            help='A coordinates array is require',\n                            location='json')\n        args = parser.parse_args()\n\n        # \u56de\u8c03\u7528\u7684\u6d88\u606f\u961f\u5217\n        que = Queue.Queue()\n\n        if app.config['RECGQUE'].qsize() > app.config['MAXSIZE']:\n            return {'message': 'Server Is Busy'}, 449\n\n        imgname = '%32x' % random.getrandbits(128)\n        imgpath = os.path.join(app.config['IMG_PATH'], '%s.jpg' % imgname)\n        try:\n            helper.get_url_img(request.json['imgurl'], imgpath)\n        except Exception as e:\n            logger.error('Error url: %s' % request.json['imgurl'])\n            return {'message': 'URL Error'}, 400\n\n        app.config['RECGQUE'].put((10, request.json, que, imgpath))\n\n        try:\n            recginfo = que.get(timeout=15)\n\n            os.remove(imgpath)\n        except Queue.Empty:\n            return {'message': 'Timeout'}, 408\n        except Exception as e:\n            logger.error(e)\n        else:\n            return {\n                'imgurl': request.json['imgurl'],\n                'coord': request.json['coord'],\n                'recginfo': recginfo\n            }, 201\n\n\nclass StateListApiV1(Resource):\n\n    def get(self):\n        return {\n            'threads': app.config['THREADS'],\n            'qsize': app.config['RECGQUE'].qsize()\n        }\n\n\nclass UploadRecgListApiV1(Resource):\n\n    def post(self):\n        # \u6587\u4ef6\u5939\u8def\u5f84 string\n        filepath = os.path.join(app.config['UPLOAD_PATH'],\n                                arrow.now().format('YYYYMMDD'))\n        if not os.path.exists(filepath):\n            os.makedirs(filepath)\n        try:\n            # \u4e0a\u4f20\u6587\u4ef6\u547d\u540d \u968f\u673a32\u4f4d16\u8fdb\u5236\u5b57\u7b26 string\n            imgname = '%32x' % random.getrandbits(128)\n            # \u6587\u4ef6\u7edd\u5bf9\u8def\u5f84 string\n            imgpath = os.path.join(filepath, '%s.jpg' % imgname)\n            f = request.files['file']\n            f.save(imgpath)\n        except Exception as e:\n            logger.error(e)\n            return {'message': 'File error'}, 400\n\n        # \u56de\u8c03\u7528\u7684\u6d88\u606f\u961f\u5217 object\n        que = Queue.Queue()\n        # \u8bc6\u522b\u53c2\u6570\u5b57\u5178 dict\n        r = {'coord': []}\n        app.config['RECGQUE'].put((9, r, que, imgpath))\n        try:\n            recginfo = que.get(timeout=app.config['TIMEOUT'])\n        except Queue.Empty:\n            return {'message': 'Timeout'}, 408\n        except Exception as e:\n            logger.error(e)\n        else:\n            return {'coord': r['coord'], 'recginfo': recginfo}, 201\n\napi.add_resource(Index, '/')\napi.add_resource(RecgListApiV1, '/v1/recg')\napi.add_resource(StateListApiV1, '/v1/state')\napi.add_resource(UploadRecgListApiV1, '/v1/uploadrecg')\n"}], "num_files": 3}
{"repo_name": "covertspatandemos/git_demo_2", "repo_url": "https://github.com/covertspatandemos/git_demo_2", "snapshot_id": "123fe18187af59b55839dbd93ecfef4d6d687b4b", "revision_id": "e74641484002fa744198e6efd83dfb6f805ae5f4", "directory_id": "7238dcf016f2fddba270c5d479bf4a297606ab52", "branch_name": "refs/heads/main", "visit_date": "2023-03-02T16:27:11.284023", "revision_date": "2021-02-12T00:56:32", "committer_date": "2021-02-12T00:56:32", "github_id": 338136419, "star_events_count": 0, "fork_events_count": 0, "gha_license_id": null, "gha_created_at": "2021-02-11T19:53:47", "gha_updated_at": "2021-02-11T23:19:55", "gha_pushed_at": "2021-02-11T23:21:00", "gha_language": "Python", "files": [{"blob_id": "b457ac1c15e8edb01ee875f8cbadfa5fd9ebd4e1", "path": "/demo.py", "content_id": "49b24a2d9225ad7ccc7dde55cb3ad65dc427b490", "language": "Python", "length_bytes": 133, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5639097690582275, "alpha_fraction": 0.5263158082962036, "num_lines": 12, "avg_line_length": 10.083333015441895, "max_line_length": 21, "content": "#!/usr/bin/env python\n\nprint('a')\nprint('b')\nprint('c')\nprint('w')\nprint('x')\nprint('1')\nprint('2')\nprint('3')\nprint('4')\nprint('5')\n"}], "num_files": 1}
{"repo_name": "Jannlk/GLO-2000-TP4", "repo_url": "https://github.com/Jannlk/GLO-2000-TP4", "snapshot_id": "2a54ee3cf77c6ef60496f0ab526fb37442be84ce", "revision_id": "7ec584c3f5db166192d3be21b3df42ab25a02f9a", "directory_id": "73818f8a0bb9386e8999dc6fa54fd84a820e1831", "branch_name": "refs/heads/master", "visit_date": "2021-08-23T22:30:52.967410", "revision_date": "2017-12-06T22:12:11", "committer_date": "2017-12-06T22:12:11", "github_id": 112973638, "star_events_count": 0, "fork_events_count": 1, "gha_license_id": null, "gha_created_at": "2017-12-03T23:44:22", "gha_updated_at": "2017-12-03T23:50:55", "gha_pushed_at": "2017-12-05T23:13:15", "gha_language": "Python", "files": [{"blob_id": "07fae31c3e817c6bc875c0e7109babedb1bc859c", "path": "/TP4_111126561/utilitaires.py", "content_id": "53a341c2e4b27258a226e4a99bce30f7bdafbe36", "language": "Python", "length_bytes": 3420, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6239693760871887, "alpha_fraction": 0.6124852895736694, "num_lines": 119, "avg_line_length": 27.53781509399414, "max_line_length": 116, "content": "import os.path\nimport re\nfrom hashlib import sha256\nfrom os.path import getsize\n\n#M\u00e9thode qui cr\u00e9e un nouveau compte dans le r\u00e9pertoire du serveur\n#id : nom du dossier\n#mdp : mot de passe\n#return : \"0\" si un probl\u00e8me est survenu avec le fichier, \"1\" si le compte a \u00e9t\u00e9 cr\u00e9\u00e9\ndef creerCompte(id, mdp):\n    state = \"1\"\n    try:\n        os.makedirs(id)\n        file = open(id + \"/config.txt\", \"w\")\n        file.write(sha256(mdp.encode()).hexdigest())\n        file.close()\n    except:\n        state = \"0\"\n    return state\n\n#M\u00e9thode qui v\u00e9rifie si le compte existe\n#id : Nom du dossier du compte\n#return: \"1\" si le compte existe, \"0\" sinon\ndef verifierID(id):\n    state = \"0\"\n    if os.path.exists(id + \"/config.txt\"):\n        state = \"1\"\n    return state\n\n#M\u00e9thode qui v\u00e9rifie si le mot de passe respecte les conditions\n#mdp : le mot de passe\n#return : \"1\" si le mot de passe respecte les conditions, \"0\" sinon.\ndef veififierMDP(mdp):\n    state = \"0\"\n    if (re.search(r\"^[a-zA-Z0-9]{6,12}$\", mdp) and re.search(r\".*[0-9].*\", mdp) and re.search(r\".*[a-zA-Z].*\",mdp)):\n        state = \"1\"\n    return state\n\n#M\u00e9thode qui permet d'ouvrir le dossier d'un utilisateur\n#id, mdp : L'identifiant et le mot de passe de l'utilisateur\n#Return : \"-1\" s'il y a un probl\u00e8me avec lors de l'ouverture du fichier\n#         \"0\" si le mot de passe de correspond pas\n#         \"1\" si la connexion est un succ\u00e8s\ndef connexion(id, mdp):\n    state = \"1\"\n    try:\n        file = open(id + \"/config.txt\", \"r\")\n        password = file.readline()\n        file.close()\n        if sha256(mdp.encode()).hexdigest() != password:\n            state = \"0\"\n    except:\n        state = \"-1\"\n\n    return state\n\n#M\u00e9thode qui permet d'ouvrir le dossier d'un utilisateur\n#id, subject, data: L'identifiant de l'utilisateur, le sujet et corps du message\n#Return : \"-1\" s'il y a un probl\u00e8me avec lors de l'ouverture du fichier\n#         \"0\" si tout se passe bien\ndef courrielLocal(id, subject, data):\n    state = \"0\"\n    try:\n        file = open(id + \"/\" + subject + \".txt\", \"w\")\n        file.write(data)\n        file.close()\n        state = \"0\"\n    except:\n        state = \"-1\"\n\n    return state\n\n#M\u00e9thode qui permet d'ouvrir un courriel local\n#subject, data: Sujet et corps du courriel\ndef ouvrirLocal(id, filename):\n    try:\n        file = open( id + \"/\" + filename, \"r\")\n        str_content = file.read();\n        file.close()\n        return str_content\n    except:\n        print(\"Fichier introuvable.\")\n\n\n\n#M\u00e9thode qui permet d'enregistrer un courriel vers un utilisateur inexistant\n#subject, data: Sujet et corps du courriel\ndef courrielDump(subject, data):\n    try:\n        if not os.path.exists(\"DESTERREUR\"):\n            os.makedirs(\"DESTERREUR\")\n        file = open(\"DESTERREUR/\" + subject + \".txt\", \"w\")\n        file.write(data)\n        file.close()\n    except:\n        print(\"Guess somebody fucked up good.\")\n\n\n#M\u00e9thode qui retourne la grosseur d'un directory\n#id: le directory\ndef getSize(id):\n    try:\n        size = getsize(id)\n        return size\n    except:\n        print(\"Mauvais nom de repertoire\")\n\n\n#M\u00e9thode qui retourne la liste tri\u00e9 par date\n#id, liste: la liste a trier\ndef sortDate(id, liste):\n    liste.sort(key=lambda x: os.path.getmtime(id + \"/\" + x))\n    return liste\n\n#M\u00e9thode qui retourne la liste tri\u00e9 alphabetiquement\n#id, liste: la liste a trier\ndef sortAlpha(liste):\n    liste = liste.sort()\n    return liste\n"}, {"blob_id": "0c1285671774a4b638f73da6624ce38a8dc1ed75", "path": "/TP4_111126561/serveur.py", "content_id": "4325ce54bbc66e749cd26fe851a89d067df7a6da", "language": "Python", "length_bytes": 6047, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.555389940738678, "alpha_fraction": 0.5373406410217285, "num_lines": 166, "avg_line_length": 35.3795166015625, "max_line_length": 115, "content": "import smtplib, re, socket, optparse, sys\nimport os.path\nimport pickle\nfrom email.mime.text import MIMEText\nimport utilitaires\n\nparser = optparse.OptionParser()\nparser.add_option(\"-a\", \"--address\", action=\"store\", dest=\"address\", default=\"localhost\")\nparser.add_option(\"-p\", \"--port\", action=\"store\", dest=\"port\", type=int, default=1337)\nopts = parser.parse_args(sys.argv[1:])[0]\n\ndestination = (opts.address, opts.port)\n#Cr\u00e9ation du socket\nserversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nserversocket.bind(destination)\nserversocket.listen(5)\nprint(\"Listening on port \" + str(serversocket.getsockname()[1]))\nnbConnexions = 0\nnbDeconnexions = 0\n\nwhile True:\n    #Un client se connecte au serveur\n    (s, address) = serversocket.accept()\n    nbConnexions += 1\n    print(str(nbConnexions) + \"e connexion au serveur\")\n\n    #R\u00e9ception du choix d'option du menu connexion.\n    option = s.recv(1024).decode()\n\n    #Si l'utilisateur choisit de se connecter\n    if option == \"1\":\n\n        #On v\u00e9rifie que le compte existe et que le mot de passe est valide\n        id = s.recv(1024).decode()\n        mdp = s.recv(1024).decode()\n        verificationID = utilitaires.verifierID(id)\n        s.send(verificationID.encode())\n        if verificationID != \"0\":\n            verificationMDP = utilitaires.connexion(id, mdp)\n            s.send(verificationMDP.encode())\n\n        while verificationID != \"1\" or verificationMDP != \"1\":\n            id = s.recv(1024).decode()\n            mdp = s.recv(1024).decode()\n            verificationID = utilitaires.verifierID(id)\n            s.send(verificationID.encode())\n            if verificationID != \"0\":\n                verificationMDP = utilitaires.connexion(id, mdp)\n                s.send(verificationMDP.encode())\n        if verificationMDP == \"-1\":\n            continue\n\n\n    #Si l'utilisateur choisit de se cr\u00e9er un compte\n    elif option == \"2\":\n        #Cr\u00e9ation de l'identifiant\n        id = s.recv(1024).decode()\n        mdp = s.recv(1024).decode()\n        verificationID = utilitaires.verifierID(id)\n        s.send(verificationID.encode())\n        if verificationID != \"1\":\n            verificationMDP = utilitaires.veififierMDP(mdp)\n            s.send(verificationMDP.encode())\n        while verificationID != \"0\" or verificationMDP != \"1\":\n            id = s.recv(1024).decode()\n            mdp = s.recv(1024).decode()\n            verificationID = utilitaires.verifierID(id)\n            s.send(verificationID.encode())\n            if verificationID != \"1\":\n                verificationMDP = utilitaires.veififierMDP(mdp)\n                s.send(verificationMDP.encode())\n        verificationErreur = utilitaires.creerCompte(id, mdp)\n        s.send(verificationErreur.encode())\n        if verificationErreur == \"0\":\n            continue\n\n\n\n    while True:\n        # R\u00e9ception du choix d'option du menu connexion.\n        option = s.recv(1024).decode()\n\n        #Envoie d'un courriel\n        if option == \"1\":\n            # reception du courriel et verification qu\u2019il est valide\n            emailFrom = s.recv(1024).decode()\n            emailAddress = s.recv(1024).decode()\n            while not re.search(r\"^[^@]+@[^@]+\\.[^@]+$\", emailAddress):\n                msg = \"-1\"\n                s.send(msg.encode())\n                emailAddress = s.recv(1024).decode()\n            msg = \"0\"\n            s.send(msg.encode())\n\n            # creation du courriel\n            subject = s.recv(1024).decode()\n            data = s.recv(1024).decode()\n            courriel = MIMEText(data)\n            courriel[\"From\"] = emailFrom\n            courriel[\"To\"] = emailAddress\n            courriel[\"Subject\"] = subject\n\n            #Externe\n            use_smtp_ulaval = False\n            if(re.match(r\"^[^@]+@reseauglo\\.ca$\", emailAddress) == None):\n                use_smtp_ulaval = True\n\n            if use_smtp_ulaval == True:\n\n                # envoi du courriel par le smtp de l'ecole\n                try:\n                    smtpConnection = smtplib.SMTP(host=\"smtp.ulaval.ca\", timeout=10)\n                    smtpConnection.sendmail(courriel[\"From\"], courriel[\"To\"], courriel.as_string())\n                    smtpConnection.quit()\n                    msg = \"0\"\n                    s.send(msg.encode())\n                except:\n                    msg = \"-1\"\n                    s.send(msg.encode())\n            else:\n                chemin_dossier = emailAddress.replace(\"@reseauglo.ca\", \"\")\n                verification = utilitaires.courrielLocal(chemin_dossier, courriel['Subject'], courriel.as_string())\n                if(verification != \"0\"):\n                    utilitaires.courrielDump(courriel['Subject'], courriel.as_string())\n                s.send(verification.encode())\n\n        elif option == \"2\":\n            id = s.recv(1024).decode()\n            files = os.listdir(id)\n            files.remove(\"config.txt\")\n            files = utilitaires.sortDate(id, files)\n            mails = []\n\n            for file in files:\n                file = file.replace(\".txt\", \"\")\n                mails.append(file)\n\n            data_string = pickle.dumps(mails)\n            s.send(data_string)\n\n            email_id = int(s.recv(1024).decode()) - 1\n            email_content = utilitaires.ouvrirLocal(id, files[email_id])\n            s.send(email_content.encode())\n\n        elif option == \"3\":\n            id = s.recv(1024).decode()\n            filesize = utilitaires.getSize(id)\n            s.send(str(filesize).encode())\n            files = os.listdir(id)\n            files.remove(\"config.txt\")\n            files = sorted(files, key=str)\n            mails = []\n\n            for file in files:\n                file = file.replace(\".txt\", \"\")\n                print(file)\n                mails.append(file)\n\n            data_string = pickle.dumps(mails)\n            s.send(data_string)\n\n        elif option == \"4\":\n            nbDeconnexions += 1\n            print(str(nbDeconnexions) + \"e deconnexion au serveur\")\n            break\n"}, {"blob_id": "3759d9129c40f0a42ba0ff1d1610bad357cd1f97", "path": "/client.py", "content_id": "2562c26dc79be015b67607c06789871fc3c80b56", "language": "Python", "length_bytes": 5652, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5427660942077637, "alpha_fraction": 0.5231096148490906, "num_lines": 152, "avg_line_length": 36.157894134521484, "max_line_length": 138, "content": "import smtplib, re, socket, optparse, sys\nimport os.path\nfrom email.mime.text import MIMEText\nfrom hashlib import sha256\nimport getpass\nimport pickle\n\nparser = optparse.OptionParser()\nparser.add_option(\"-a\", \"--address\", action=\"store\", dest=\"address\", default=\"localhost\")\nparser.add_option(\"-p\", \"--port\", action=\"store\", dest=\"port\", type=int, default=1337)\nopts = parser.parse_args(sys.argv[1:])[0]\n\ndestination = (opts.address, opts.port)\n#Connexion au serveur\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.settimeout(10)\ns.connect(destination)\ns.settimeout(None)\n\nwhile True:\n    #Menu de connexion, choix d'une option\n    option = input(\"Menu de connexion \\n1. Se connecter \\n2. Creer un compte \\n\")\n    while option != \"1\" and option != \"2\":\n        option = input(\"Veuillez saisir une option valide:\\n\")\n    s.send(option.encode())\n\n    #Se connecter\n    if option == \"1\":\n        id = input(\"Veuillez saisir votre identifiant:\\n\")\n        mdp = getpass.getpass(\"Veuillez saisir votre mot de passe:\\n\")\n        s.send(id.encode())\n        s.send(mdp.encode())\n        reponseID = s.recv(1024).decode()\n        if reponseID != \"0\":\n            reponseMDP = s.recv(1024).decode()\n        while reponseID != \"1\" or reponseMDP != \"1\":\n            if reponseID != \"1\":\n                id = input(\"Veuillez saisir un identifiant valide:\\n\")\n                mdp = getpass.getpass(\"Veuillez saisir votre mot de passe:\\n\")\n            elif reponseMDP == \"-1\":\n                print(\"Desole, un probleme est survenu.\")\n                continue\n            else:\n                print(\"Ce n'est pas le bon mot de passe. Veuillez reessayer.\")\n                id = input(\"Veuillez saisir votre identifiant:\\n\")\n                mdp = getpass.getpass(\"Veuillez saisir votre mot de passe:\\n\")\n            s.send(id.encode())\n            s.send(mdp.encode())\n            reponseID = s.recv(1024).decode()\n            if reponseID != \"0\":\n                reponseMDP = s.recv(1024).decode()\n\n\n\n    #Cr\u00e9er un compte\n    elif option == \"2\":\n        id = input(\"Veuillez choisir un identifiant:\\n\")\n        mdp = getpass.getpass(\"Veuillez choisir un mot de passe contenant de 6 \u00e0 12 carateres, dont au moins une lettre et un chiffre:\\n\")\n        s.send(id.encode())\n        s.send(mdp.encode())\n        reponseID = s.recv(1024).decode()\n        if reponseID != \"1\":\n            reponseMDP = s.recv(1024).decode()\n        while reponseID != \"0\" or reponseMDP != \"1\":\n            if reponseID != \"0\":\n                id = input(\"Cet identifiant est deja pris, veuillez en choisir un autre:\\n\")\n                mdp = getpass.getpass(\"Veuillez saisir votre mot de passe:\\n\")\n            else:\n                print(\"Ce mot de passe ne respecte pas les conditions, veuilelz en choisir un autre.\")\n                id = input(\"Veuillez saisir votre identifiant a nouveau:\\n\")\n                mdp = getpass.getpass(\"Veuillez saisir votre nouveau mot de passe:\\n\")\n            s.send(id.encode())\n            s.send(mdp.encode())\n            reponseID = s.recv(1024).decode()\n            if reponseID != \"1\":\n                reponseMDP = s.recv(1024).decode()\n        reponseCreationCompte = s.recv(1024).decode()\n        if reponseCreationCompte == \"0\":\n            print(\"Desole, un probleme est survenu\")\n            continue\n\n\n    while True:\n        option = input(\"\\nMenu principale\\n1. Envoi de courriels\\n2. Consultation de courriels\\n3. Statistiques\\n4. Quitter\\n\")\n        while option not in  [\"1\", \"2\", \"3\", \"4\"]:\n            option = input(\"Veuillez saisir une option valide:\\n\")\n\n        s.send(option.encode())\n\n        if option == \"1\":\n            email_from = id + \"@reseauglo.ca\"\n            s.send(email_from.encode())\n\n            response = \"-1\"\n            while(response == \"-1\"):\n                email_to = input(\"\\n\u00c0: \")\n                s.send(email_to.encode())\n                response = s.recv(1024).decode()\n\n            subject = input(\"\\nSujet: \")\n            s.send(subject.encode())\n            data = input(\"\\nMessage: \")\n            s.send(data.encode())\n\n            response = s.recv(1024).decode()\n            if(response == \"-1\"):\n                print(\"\\nErreur lors de l'envoie du courriel.\")\n                continue\n            else:\n                print(\"\\nCourriel envoy\u00e9 avec succ\u00e8s!\")\n        elif option == \"2\":\n            s.send(id.encode())\n            data_string = s.recv(1024)\n            mails = pickle.loads(data_string)\n\n            print(\"\\nListe de vos courriels: \\n\")\n\n            compteur = 1;\n            for mail in mails:\n                print(\"\\n\" + str(compteur) + \". \" + mail)\n                compteur += 1\n\n            email_id = input(\"\\nQuel courriel souhaitez-vous visionner? \\n\")\n\n            s.send(email_id.encode())\n\n            email_content = s.recv(1024).decode()\n            print(\"\\n\" + email_content)\n            input(\"\\nAppuyez sur Enter pour continuer...\")\n            continue\n        elif option == \"3\":\n            s.send(id.encode())\n\n            filesize = s.recv(1024).decode()\n\n            data_string = s.recv(1024)\n            mails = pickle.loads(data_string)\n\n            print(\"\\nNombre de messages: \" + str(len(mails)) + \"\\n\")\n            print(\"\\nTaille du repertoire personnel (en octets): \" + filesize + \"\\n\")\n            print(\"\\nListe de vos courriels: \\n\")\n\n            compteur = 1;\n            for mail in mails:\n                print(\"\\n\" + str(compteur) + \". \" + mail)\n                compteur += 1\n            input(\"\\nAppuyez sur Enter pour continuer...\")\n            continue\n        elif option == \"4\":\n            break;\n    s.close()\n    exit()"}, {"blob_id": "8399e216f1d1b06d092ac5c27e2752885a4e2f38", "path": "/README.md", "content_id": "8c0736834fff0f67545bb534f39841089217a22d", "language": "Markdown", "length_bytes": 393, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7289002537727356, "alpha_fraction": 0.7033247947692871, "num_lines": 11, "avg_line_length": 34.54545593261719, "max_line_length": 91}], "num_files": 4}
{"repo_name": "tattle-made/archive-telegram-bot", "repo_url": "https://github.com/tattle-made/archive-telegram-bot", "snapshot_id": "960de3b2e69f3369a4a5d91a25a86e682bcdca51", "revision_id": "cfb69968fb894b173e7d5e9b077cd35b60b7f8ec", "directory_id": "349e1bb6b4b64130370b1b3b61216f1727327076", "branch_name": "refs/heads/master", "visit_date": "2023-04-14T22:26:53.221002", "revision_date": "2020-10-07T03:08:07", "committer_date": "2020-10-07T03:08:07", "github_id": 239930069, "star_events_count": 0, "fork_events_count": 1, "gha_license_id": null, "gha_created_at": "2020-02-12T04:54:05", "gha_updated_at": "2020-10-07T03:08:15", "gha_pushed_at": "2022-12-08T03:36:00", "gha_language": "Python", "files": [{"blob_id": "cbe4f342f014c55ad391373a4b7ccd2bff83d408", "path": "/tattle_helper.py", "content_id": "7864b8b541dd7e9f3971e8104061e1aea1ac36c5", "language": "Python", "length_bytes": 1868, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6884368062019348, "alpha_fraction": 0.6729121804237366, "num_lines": 60, "avg_line_length": 30.149999618530273, "max_line_length": 134, "content": "import os\nimport json\nimport boto3\nimport requests\nfrom logger import log, logError\nfrom dotenv import load_dotenv\nload_dotenv()\n\ns3 = boto3.client(\"s3\",aws_access_key_id=os.environ.get('S3_ACCESS_KEY'),aws_secret_access_key=os.environ.get('S3_SECRET_ACCESS_KEY'))\n\nAPI_BASE_URL = \"https://archive-server.tattle.co.in\"\n# API_BASE_URL = \"https://postman-echo.com/post\"\nARCHIVE_TOKEN = os.environ.get('ARCHIVE_TOKEN')\n\ndef register_post(data):\n\t\"\"\"\n\t\tregisters a post on archive server\n\t\"\"\"\n\turl_to_post_to = API_BASE_URL+\"/api/posts\"\n\tpayload = json.dumps(data)\n\theaders = {\n\t\t'token': ARCHIVE_TOKEN,\n\t\t'Content-Type': \"application/json\",\n\t\t'cache-control': \"no-cache\",\n    }\n\n\ttry:\n\t\tr = requests.post(url_to_post_to, data=payload, headers=headers)\n\n\t\tif r.status_code==200:\n\t\t\tlog('STATUS CODE 200 \\n'+json.dumps(r.json(), indent=2))\n\t\telse:\n\t\t\tlog('STATUS CODE '+str(r.status_code)+'\\n '+r.text)\n\texcept:\n\t\tlog('error with API call')\n\n\ndef upload_file(file_name, s3=s3 ,acl=\"public-read\"):\n\tbucket_name = os.environ.get('TGM_BUCKET_NAME')\n\t#opens file, reads it, and uploads it to the S3 bucket.\n\ttry:\n\t\twith open(file_name, 'rb') as data:\n\t\t\ts3.upload_fileobj(data,bucket_name,file_name,ExtraArgs={\"ACL\": acl,\"ContentType\": file_name.split(\".\")[-1]})\n\texcept:\n\t\tlogError('ERROR_S3_UPLOAD of '+file_name)\n\t\n\tfile_url = \"https://s3.ap-south-1.amazonaws.com/\"+bucket_name+\"/\"+file_name\n\treturn file_url\n\ndef upload_file(file_name, s3=s3 ,acl=\"public-read\"):\n\tbucket_name = os.environ.get('TGM_BUCKET_NAME')\n\t#opens file, reads it, and uploads it to the S3 bucket.\n\ttry:\n\t\twith open(file_name, 'rb') as data:\n\t\t\ts3.upload_fileobj(data,bucket_name,file_name,ExtraArgs={\"ACL\": acl,\"ContentType\": file_name.split(\".\")[-1]})\n\texcept:\n\t\tlogError('ERROR_S3_UPLOAD of '+file_name)\n\t\n\tfile_url = \"https://s3.ap-south-1.amazonaws.com/\"+bucket_name+\"/\"+file_name\n\treturn file_url"}, {"blob_id": "370248369505aecb1d72db0af1730b195aeed570", "path": "/README.md", "content_id": "688d30d126f49c3505815c7e5dcc87573fb4aade", "language": "Markdown", "length_bytes": 453, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7682119011878967, "alpha_fraction": 0.7637969255447388, "num_lines": 20, "avg_line_length": 21.700000762939453, "max_line_length": 180}, {"blob_id": "42e4c5ee70d7e32317a7cd19f2016b7ee8cb838b", "path": "/Dockerfile", "content_id": "0a542f24805a2ead9202516a5a6153300b2dae87", "language": "Dockerfile", "length_bytes": 316, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7753164768218994, "alpha_fraction": 0.7341772317886353, "num_lines": 14, "avg_line_length": 21.64285659790039, "max_line_length": 35}, {"blob_id": "4008f9e0cf0958f8c777107b9f46c5132988df53", "path": "/post_request.py", "content_id": "b853338959cf8dd35f488aa3a392b80ebff42d8f", "language": "Python", "length_bytes": 713, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5666199326515198, "alpha_fraction": 0.530154287815094, "num_lines": 26, "avg_line_length": 26.461538314819336, "max_line_length": 79, "content": "token = \"78a6fc20-fa83-11e9-a4ad-d1866a9a3c7b\" # add your token here\nurl = \"<base-api-url>/api/posts\"\ntry:\n    payload = d\n    payload = json.dumps(payload)\n    headers = {\n        'token': token,\n        'Content-Type': \"application/json\",\n        'cache-control': \"no-cache\",\n        }\n    r = requests.post(url, data=payload, headers=headers)\n    if r.ok:\n        print ('success')\n    else:\n        print ('something went wrong')\n              \nexcept:\n    logging.exception('error in POST request')\n    raise\n                 \n{\n    \"type\" : \"image\", # can be image, text, video\n    \"data\" : \"\",\n    \"filename\": \"4bf4b1cc-516b-469d-aa38-be6762d417a5\", #filename you put on s3\n    \"userId\" : 169 # for telegram_bot this should be 169\n}"}, {"blob_id": "657cb734d1f214bf11feea89a212ab22ae350bb8", "path": "/test.py", "content_id": "2f95039e6944afda5d099d80e805898e866781ff", "language": "Python", "length_bytes": 232, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.625, "alpha_fraction": 0.6120689511299133, "num_lines": 13, "avg_line_length": 16.923076629638672, "max_line_length": 52, "content": "from tattle_helper import register_post, upload_file\n\ndata = {\n    \"type\" : \"image\",\n    \"data\" : \"\",\n    \"filename\": \"asdf\",\n    \"userId\" : 169\n}\n\nresponse = upload_file(file_name='denny.txt')\nprint(response)\n\n# register_post(data)"}, {"blob_id": "94a3746880941d95cc3db53a80895fb4ed9c85c2", "path": "/prototype.py", "content_id": "627418cc040fdd7f06e17568c791673f9facf261", "language": "Python", "length_bytes": 14564, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6542845368385315, "alpha_fraction": 0.6523619890213013, "num_lines": 354, "avg_line_length": 40.14124298095703, "max_line_length": 756, "content": "import os\nimport sys\nimport json\nimport requests\nimport telegram\nimport logging\nimport re\nfrom threading import Thread\nfrom telegram.ext import CommandHandler, MessageHandler, Updater, Filters, InlineQueryHandler\nfrom telegram import InlineQueryResultArticle, InputTextMessageContent\nfrom telegram.ext.dispatcher import run_async\nfrom dotenv import load_dotenv\nfrom pymongo import MongoClient\nfrom logger import log, logError\nfrom tattle_helper import upload_file\n\n# loads all environment variables\nload_dotenv()\n\nlog('STARTING APP v1')\n\n\nTOKEN = os.environ.get('ACCESS_TOKEN')\nPORT = int(os.environ.get('PORT', '8443'))\nprint(TOKEN)\n\n# logging.basicConfig(filename='telegram_bot_log.log',filemode='a',format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)\n\n# Calls for Database modification and reads start\n\n\ndef insert_document(document, required_collection):\n    return db[required_collection].insert_one(document)\n\n\ndef find_document(query, required_collection):\n    return db[required_collection].find_one(query)\n\n\ndef update_document(find_query, update_query, required_collection, upsert=False):\n    return db[required_collection].update_one(find_query, update_query, upsert)\n\n\ndef delete_document(find_query, required_collection):\n    return db[required_collection].delete_one(find_query)\n# Calls for Database modification and reads end\n@run_async\ndef start(update, context):\n    # start message\n    context.bot.send_message(chat_id=update.effective_chat.id, text=\"Hey! \\n\\nI'm the Tattle Bot. Here are some instructions to use me:\\n\\n1. You can send whatever content to me that you'd like. All mediums : Text, Video, and Photos are allowed.\\n2. You can tag your content using hashtags. When uploading photos or videos you can mention the tags in the caption, with text you can just tag it at the end or in the beginning(anywhere else in the text will also work).\\n3. You can edit your messages after you've sent them, we'll update them in our database accordingly.\\n 4. In case you miss tagging a message, you can reply to that message and insert the tags required. Only tags will be extracted, so please don't write text while replying to messages.\")\n\n\ndef determine_type(message_json):\n    # checks what type of content is being passed, and returns the type\n    type_of_content = ''\n    if(message_json.text):\n        type_of_content = 'text'\n    elif(message_json.photo):\n        type_of_content = 'photo'\n    elif(message_json.video):\n        type_of_content = 'video'\n    elif(message_json.document):\n        type_of_content = 'document'\n    return type_of_content\n\n\ndef entity_extraction(all_entities, message_content):\n    # entity extraction, which basically extracts all the hashtags out of the message\n    list_of_tags = []\n    if(bool(all_entities)):\n        # checks if there are any entities, and if so loops over them\n        for each_entity in all_entities:\n            if(each_entity['type'] == 'hashtag'):\n                # string slicing based on offset and length values\n                tag = message_content[each_entity['offset']:(\n                    each_entity['offset']+each_entity['length'])]\n                list_of_tags.append(tag)\n    if(bool(list_of_tags)):\n        # converts to set to remove duplicates\n        return list(set(list_of_tags))\n    else:\n        return None\n\n\ndef new_tags(message_json, current_document, all_tags):\n    # adds or replaces tags in messages that had no tags or in case of edits\n    new_tags = all_tags\n    update_document({'message_id': message_json.reply_to_message.message_id}, {\n                    \"$set\": {\"reply_tags\": new_tags}}, 'messages')\n\n\ndef error_message(message_json):\n    # standard error message\n    context.bot.send_message(chat_id=message_json.chat.id,\n                             text=\"Something went wrong with registering these tags, apologies for the same.\")\n\n\ndef reply_to_messages(message_json, edit_flag):\n\n    all_tags = entity_extraction(message_json.entities, message_json.text)\n\n    if(all_tags is not None):\n        # first finds the document that the reply is being done to\n        current_document = find_document(\n            {'message_id': message_json.reply_to_message.message_id}, 'messages')\n\n        try:\n            # add reply tags with a new key called reply_tags\n            new_tags(message_json, current_document, all_tags)\n        except:\n            # or, throw an error message and log\n            error_message()\n            raise\n\n\ndef edit_message(message_json, final_dict, content_type, context):\n    tags = []\n    # check content type before processing the data\n    if(content_type == 'text'):\n        # In case of edits, we need to replace file on S3. Replacing happens automatically as long as file name is same.\n        file_name = str(message_json.message_id) + '.txt'\n        with open(file_name, 'w') as open_file:\n            open_file.write(message_json['text'])\n        upload_file(file_name)\n        os.remove(file_name)\n\n        final_dict = process_text(\n            message_json, final_dict, message_json['text'], False)\n    else:\n        final_dict = process_media(\n            message_json, final_dict, content_type, context, False)\n\n    # in case message is being edited, we first find the document being edited\n    current_document = find_document(\n        {'message_id': message_json.message_id}, 'messages')\n\n    # we check if the document had any existing tags, if so we store them before deleting the document\n    # FLAW IN CODE : If existing tags are being edited, it doesn't reflect this way. NEED TO FIX.\n    try:\n        tags = current_document['tags']\n    except KeyError:\n        tags = None\n\n    try:\n        reply_tags = current_document['reply_tags']\n    except KeyError:\n        reply_tags = None\n\n    if(reply_tags is not None):\n        final_dict['reply_tags'] = reply_tags\n    # add tags to final dict for new, edited document\n    if(tags is not None):\n        final_dict['tags'] = tags\n\n    # delete the document\n    delete_document({'message_id': message_json.message_id}, 'messages')\n    # insert edited document\n    insert_document(final_dict, 'messages')\n\n\ndef process_text(message_json, final_dict, message_content, caption_flag):\n    # check if we're processing a caption or a text message\n    if(caption_flag):\n        all_tags = entity_extraction(\n            message_json['caption_entities'], message_content)\n    else:\n        all_tags = entity_extraction(message_json['entities'], message_content)\n    # check if any tags are present\n    if(all_tags is not None):\n        final_dict['tags'] = all_tags\n\n    if(bool(message_content)):\n        # cleans out the hashtags\n        modified_message = re.sub(r'#\\w+', '', message_content)\n        # removes all excessive spacing\n        cleaned_message = re.sub(' +', ' ', modified_message)\n        # changes key based on whether it is a caption or not\n        if(caption_flag):\n            # removing leading and trailing spaces\n            final_dict['caption'] = cleaned_message.strip()\n        else:\n            final_dict['text'] = cleaned_message.strip()\n    return final_dict\n\n    # just for testing\n    # BASE_URL = \"http://archive-telegram-bot.tattle.co.in.s3.amazonaws.com/\"\n    # print(\"{}{}\".format(BASE_URL, file_name))\n\n\ndef make_post_request(dict_to_post):\n    log('***')\n    log(dict_to_post)\n    API_BASE_URL = \"https://archive-server.tattle.co.in\"\n    access_token = os.environ.get('ARCHIVE_TOKEN')\n    url_to_post_to = API_BASE_URL+\"/api/posts\"\n    payload = json.dumps(dict_to_post)\n    headers = {\n        'token': access_token,\n        'Content-Type': \"application/json\",\n        'cache-control': \"no-cache\",\n    }\n    r = requests.post(url_to_post_to, data=payload, headers=headers)\n    print('API response')\n    print(r)\n    # print(r.json())\n\n\ndef construct_dict(file_name, file_type):\n    return {\"type\": file_type, \"data\": \"\", \"filename\": file_name, \"userId\": 169}\n\n\ndef process_media(message_json, final_dict, content_type, context, creation_flag):\n\n    # check if content type is photo, and constructs dict and file_name appropriately\n    if(content_type == 'photo'):\n        final_dict['photo'] = [{'file_id': each_photo.file_id, 'width': each_photo.width,\n                                'height': each_photo.height, 'file_size': each_photo.file_size} for each_photo in message_json.photo]\n        file_id = message_json.photo[-1].file_id\n        file_name = str(message_json.message_id)+'.jpeg'\n        post_request_type = 'image'\n\n    # same with video as above\n    elif(content_type == 'video'):\n        final_dict['video'] = {'file_id': message_json.video.file_id, 'width': message_json.video.width, 'height': message_json.video.height, 'duration': message_json.video.duration, 'thumb': {'file_id': message_json.video.thumb.file_id,\n                                                                                                                                                                                                 'width': message_json.video.thumb.width, 'height': message_json.video.thumb.height, 'file_size': message_json.video.thumb.file_size}, 'mime_type': message_json.video.mime_type, 'file_size': message_json.video.file_size}\n        file_id = message_json.video.file_id\n        file_type = str(message_json.video.mime_type).split(\"/\")[-1]\n        file_name = str(message_json.message_id)+\".\"+file_type\n        post_request_type = 'video'\n    # process_media is only called from two places, one of which is when message is edited. Since we don't want duplicates, we set a flag to differentiate.\n    if(creation_flag):\n        try:\n            new_file = context.bot.get_file(file_id)\n            new_file.download(file_name)  # downloads the file\n            final_dict['file_name'] = file_name\n            file_url = upload_file(file_name)  # uploads to S3\n            final_dict['s3_url'] = file_url\n            os.remove(file_name)  # removes it from local runtime\n\n            request_dict = construct_dict(file_name, post_request_type)\n            make_post_request(request_dict)\n        except:\n            logging.exception(\n                \"The file_name when the error happened is: {}\".format(file_name))\n\n    # process any caption or text found\n    final_dict = process_text(message_json, final_dict,\n                              message_json.caption, True)\n    return final_dict\n\n\n@run_async\ndef storing_data(update, context):\n    log(update)\n\n    final_dict = {}\n    # print(update)\n    # selects just the effective_message part\n    relevant_section = update.effective_message\n    # some general data appended to each dict\n    final_dict['message_id'] = relevant_section['message_id']\n    final_dict['date'] = relevant_section['date']\n    # final_dict['from'] = {'id':relevant_section.from_user.id,'type':relevant_section.chat.type,'first_name':relevant_section.from_user.first_name,'last_name':relevant_section.from_user.last_name,'username':relevant_section.from_user.username,'is_bot':relevant_section.from_user.is_bot}\n    content_type = determine_type(relevant_section)\n    final_dict['content_type'] = content_type\n\n    # checks if the request is that of an edition\n    if(relevant_section.edit_date):\n        # if yes, checks if the edited message was replying to another message\n        if(relevant_section.reply_to_message):\n            # if yes, then deals with it by setting edit flag to True\n            reply_to_messages(relevant_section, True)\n            return\n        else:\n            # else, just edits the message normally\n            edit_message(relevant_section, final_dict, content_type, context)\n            return\n    # if the message is a reply, then respond appropriately\n    if(relevant_section.reply_to_message):\n        # edit flag is set to false because we're just handling simple reply\n        reply_to_messages(relevant_section, False)\n        return\n\n    if(content_type == 'text'):\n        # creates file with message ID, then writes the text into the file and uploads it to S3\n        try:\n            file_name = str(relevant_section.message_id) + '.txt'\n            with open(file_name, 'w') as open_file:\n                open_file.write(relevant_section['text'])\n            file_url = upload_file(file_name)\n            final_dict['s3_url'] = file_url\n            os.remove(file_name)\n\n            request_dict = construct_dict(file_name, content_type)\n            r = make_post_request(request_dict)\n        except Exception as e:\n            logging.exception(\n                \"The file_name when the error happened is: {}\".format(file_name))\n            logging.exception(e)\n\n        # if new text message, process it and then insert it in the database\n        final_dict = process_text(\n            relevant_section, final_dict, relevant_section['text'], False)\n        insert_document(final_dict, 'messages')\n    else:\n        final_dict = process_media(\n            relevant_section, final_dict, content_type, context, True)\n        insert_document(final_dict, 'messages')\n\n    context.bot.send_message(\n        chat_id=update.effective_chat.id, text='message archived')\n    # context.bot.send_message(chat_id=update.effective_chat.id, text=update.message.text)\n\n\ndef stop_and_restart():\n    \"\"\"Gracefully stop the Updater and replace the current process with a new one\"\"\"\n    updater.stop()\n    os.execl(sys.executable, sys.executable, *sys.argv)\n\n\ndef restart(update, context):\n    update.message.reply_text('Bot is restarting...')\n    Thread(target=stop_and_restart).start()\n\n\ntry:\n    client = MongoClient(\"mongodb+srv://\"+os.environ.get(\"TGM_DB_USERNAME\")+\":\"+os.environ.get(\"TGM_DB_PASSWORD\") +\n                         \"@tattle-data-fkpmg.mongodb.net/test?retryWrites=true&w=majority&ssl=true&ssl_cert_reqs=CERT_NONE\")\n    db = client[os.environ.get(\"TGM_DB_NAME\")]\nexcept error_message:\n    print('error connecting to db')\n    print(error_message)\n\nupdater = Updater(token=TOKEN, use_context=True, workers=32)\ndispatcher = updater.dispatcher\nstart_handler = CommandHandler('start', start)\nstoring_data_handler = MessageHandler(Filters.all, storing_data)\nrestart_handler = CommandHandler(\n    'r', restart, filters=Filters.user(username='@thenerdyouknow'))\n\ndispatcher.add_handler(restart_handler)\ndispatcher.add_handler(start_handler)\ndispatcher.add_handler(storing_data_handler)\n\n# updater.start_webhook(listen=\"0.0.0.0\",\n# \tport=PORT,\n# \turl_path=TOKEN)\n\n# updater.bot.set_webhook(\"https://services-server.tattle.co.in/\" + TOKEN)\nupdater.start_polling()\nupdater.idle()\n\n\nlog('STARTING SERVER v1.0')\n"}, {"blob_id": "9807a5ebb96dd04c28e364b029a256bee567eae1", "path": "/logger.py", "content_id": "dcba379b5d76fb951f1d32fcc0443cc00eb3bb91", "language": "Python", "length_bytes": 185, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5567567348480225, "alpha_fraction": 0.5567567348480225, "num_lines": 10, "avg_line_length": 17.600000381469727, "max_line_length": 41, "content": "from datetime import datetime\n\ndef log(data):\n    print('----', datetime.now(), '----')\n    print(data)\n\n\ndef logError(error):\n    print('****', datetime.now(), '****')\n    print(error)"}, {"blob_id": "68ee6af660ac8c5d9bca666aff53aece12f09701", "path": "/requirements.txt", "content_id": "370b0913e369c37551115e01129b23338ffcbe7e", "language": "Text", "length_bytes": 392, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7015306353569031, "alpha_fraction": 0.4770408272743225, "num_lines": 24, "avg_line_length": 15.333333015441895, "max_line_length": 27}], "num_files": 8}
{"repo_name": "riadghorra/whiteboard-oop-project", "repo_url": "https://github.com/riadghorra/whiteboard-oop-project", "snapshot_id": "361304ea2e4fd65127480ba4ee147aa0ba08079f", "revision_id": "b022bae06b6d04ac05148b317418545ce3a51c57", "directory_id": "672d93e05857e4a0f5d6bec070bd1e35b3a084ee", "branch_name": "refs/heads/master", "visit_date": "2020-07-31T11:34:55.348224", "revision_date": "2019-11-26T13:42:08", "committer_date": "2019-11-26T13:42:08", "github_id": 210590571, "star_events_count": 0, "fork_events_count": 1, "gha_license_id": null, "gha_created_at": "2019-09-24T11:53:13", "gha_updated_at": "2019-11-21T14:29:53", "gha_pushed_at": "2019-11-21T17:58:00", "gha_language": "Python", "files": [{"blob_id": "b7c98400ba00bde452522ac170ebb36055c7615c", "path": "/src/figures.py", "content_id": "a47c280d91f87704858d9dff10cabba549441a6f", "language": "Python", "length_bytes": 11966, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5777592062950134, "alpha_fraction": 0.5726588368415833, "num_lines": 354, "avg_line_length": 32.785308837890625, "max_line_length": 116, "content": "\"\"\"\nModule contenant toutes les figures et op\u00e9rations de base\n\"\"\"\n\nimport pygame\nimport pygame.draw\nfrom datetime import datetime\n\n\ndef distance(v1, v2):\n    \"\"\"\n    Calcule la distance euclidienne entre deux vecteurs\n    \"\"\"\n    try:\n        return ((v1[0] - v2[0]) ** 2 + (v1[1] - v2[1]) ** 2) ** 0.5\n    except TypeError:\n        return \"Ce ne sont pas des vecteurs\"\n\nclass Figure:\n    def __init__(self):\n        pass\n    def draw(self):\n        pass\n    def fetch_params(self):\n        pass\n\nclass Point(Figure):\n    \"\"\"\n    Classe d'un point pr\u00eat \u00e0 \u00eatre trac\u00e9 sur le tableau\n    coord (list) : coordon\u00e9es\n    point_color (list) : couleur en RGB\n    font_size (int) : epaisseur en pixels\n    toolbar_size (int) : epaisseur de la toolbar en haut du tableau sur laquelle on ne veut pas que le point depasse\n    \"\"\"\n\n    def __init__(self, coord, point_color, font_size, toolbar_size=0):\n        Figure.__init__(self)\n        self.point_color = point_color\n        self.font_size = font_size\n\n        # used to not write on the toolbar if the font size is big\n        self.coord = [coord[0], max(coord[1], toolbar_size + font_size + 1)]\n        self.type = \"Point\"\n\n    def draw(self, screen):\n        \"\"\"\n        Dessine le point sur l'ecran\n        \"\"\"\n        pygame.draw.circle(screen, self.point_color, self.coord, self.font_size)\n        pygame.display.flip()\n        return\n\n    def fetch_params(self):\n        \"\"\"\n        Retourne un dictionnaire des parametres\n        \"\"\"\n        return {\"coord\": self.coord, \"point_color\": self.point_color, \"font_size\": self.font_size}\n\n\nclass Line(Figure):\n    \"\"\"\n    Classe d'une ligne droite\n    line_color (list) : couleur de la ligne en RGB\n    start_pos (list): coordonee du debut de la ligne droite\n    end_pos (list) : coordonee de la fin de la ligne droite\n    font_size (int): epaisseur\n    \"\"\"\n\n    def __init__(self, line_color, start_pos, end_pos, font_size):\n        Figure.__init__(self)\n        self.line_color = line_color\n        self.start_pos = start_pos\n        self.end_pos = end_pos\n        self.font_size = font_size\n        self.type = \"Line\"\n\n    def draw(self, screen):\n        \"\"\"\n        Dessine la ligne sur l'ecran\n        \"\"\"\n        pygame.draw.line(screen, self.line_color, self.start_pos, self.end_pos, self.font_size)\n        return\n\n    def fetch_params(self):\n        \"\"\"\n        Retourne un dictionnaire des parametres\n        \"\"\"\n        return {\"line_color\": self.line_color, \"start_pos\": self.start_pos, \"end_pos\": self.end_pos,\n                \"font_size\": self.font_size}\n\n\nclass Rectangle(Figure):\n    \"\"\"\n    Classe d un rectangle\n    color (list) : couleur du rectangle\n    left, right (int) : coordonees d'absice a gauche, droite du rectangle\n    bottom, top (int) : coordonees d'ordonnee en haut et en bas du rectangle\n    \"\"\"\n\n    def __init__(self, c1, c2, color):\n        \"\"\"\n        On definit les parametres du rectangle a partir des coordonees de deux coins\n        c1, c2 (lists): coordonees de deux coins du rectangle\n        \"\"\"\n        Figure.__init__(self)\n        self.c1 = c1\n        self.c2 = c2\n        self.color = color\n        # on recupere left avec le min des abscisses et on fait pareil pour right top et bottom\n        self.left = min(c1[0], c2[0])\n        self.top = min(c1[1], c2[1])\n        self.right = max(c1[0], c2[0])\n        self.bottom = max(c1[1], c2[1])\n        self.width = self.right - self.left\n        self.length = self.bottom - self.top\n        self.rect = pygame.Rect(self.left, self.top, self.width, self.length)\n        self.type = \"rect\"\n\n    def draw(self, screen):\n        \"\"\"\n        Dessine le rectangle sur l'ecran\n        \"\"\"\n        pygame.draw.rect(screen, self.color, self.rect, 0)\n\n    def fetch_params(self):\n        \"\"\"\n        Retourne un dictionnaire des parametres\n        \"\"\"\n        return {\"c1\": self.c1, \"c2\": self.c2, \"color\": self.color}\n\n\nclass Circle(Figure):\n    \"\"\"\n    Classe d un cercle\n    center (list) : les coordonees du centre\n    extremity (list) : les coordonees d'une extremite\n    color (list) : couleur\n    toolbar_size (int) : la taille de la toolbar en pixel pour ne pas dessiner dessus\n    radius (int) : rayon\n    \"\"\"\n\n    def __init__(self, center, extremity, color, toolbar_size=0):\n        Figure.__init__(self)\n        self.center = center\n        # on ne veut pas depasser sur la toolbar donc on reduit le rayon\n        self.radius = min(int(distance(center, extremity)), center[1] - toolbar_size - 1)\n        self.extremity = [center[0] + self.radius, center[1]]\n        self.color = color\n        self.type = \"circle\"\n\n    def draw(self, screen):\n        \"\"\"\n        dessine le cercle sur l ecran\n        \"\"\"\n        pygame.draw.circle(screen, self.color, self.center, self.radius)\n\n    def fetch_params(self):\n        \"\"\"\n        Retourne un dictionnaire des parametres\n        \"\"\"\n        return {\"center\": self.center, \"extremity\": self.extremity, \"color\": self.color}\n\n\nclass TextBox(Figure):\n    \"\"\"\n    Classe d une textbox\n    x, y (int) : l'abscisse a gauche et l'ordonee a droite de la textbox ie (x,y) est le topleft\n    w (int) : longueur de la textbox\n    h (int) : hauteur de la textbox\n    box_color (list) : couleur du contour de la box\n    font (string) : police du texte\n    font_size (int) : taille des caracteres\n    text (string) : texte de la texbox\n    text_color (list) : couleur du texte\n    \"\"\"\n\n    def __init__(self, x, y, w, h, box_color, font, font_size, text, text_color):\n        Figure.__init__(self)\n        self.__rect = pygame.Rect(x, y, w, h)\n        self._color = box_color\n        self._text = text\n        self._font = font\n        self._font_size = font_size\n        self._sysfont = pygame.font.SysFont(font, font_size)\n        self._text_color = text_color\n        self._txt_surface = self._sysfont.render(text, True, self._text_color)\n        self.id_counter = str(x) + \"_\" + str(y)\n        self.type = \"Text_box\"\n\n    \"\"\"\n    Encapsulation\n    \"\"\"\n\n    def fetch_params(self):\n        \"\"\"\n        Retourne un dictionnaire des parametres\n        \"\"\"\n        return {\"x\": self.__rect.x, \"y\": self.__rect.y, \"w\": self.__rect.w, \"h\": self.__rect.h,\n                \"box_color\": self._color, \"font\": self._font, \"font_size\": self._font_size, \"text\": self._text,\n                \"text_color\": self._text_color}\n\n    def get_textbox_color(self):\n        return self._color\n\n    def set_textbox_color(self, new_color):\n        self._color = new_color\n\n    def get_textbox_text(self):\n        return self._text\n\n    def add_character_to_text(self, char, whiteboard):\n        \"\"\"\n        rajoute un caractere au texte\n        \"\"\"\n\n        id_counter = whiteboard.active_box.id_counter\n        for action in [x for x in whiteboard.get_hist('actions') if x['type'] == 'Text_box']:\n            if action['id'] == id_counter:\n                if action['owner'] in whiteboard.modification_allowed or action['owner'] == whiteboard.name:\n                    self._text += char\n                    action['params'][\"text\"] = whiteboard.active_box.get_textbox_text()\n                    action['params'][\"w\"] = whiteboard.active_box.update()\n                    now = datetime.now()\n                    timestamp = datetime.timestamp(now)\n                    action['timestamp'] = timestamp\n                    action['client'] = whiteboard.name\n                    action_to_update_textbox = action\n        for textbox in whiteboard.get_text_boxes():\n            if textbox.id_counter == id_counter:\n                if action['owner'] in whiteboard.modification_allowed or action['owner'] == whiteboard.name:\n                    whiteboard.del_text_box(textbox)\n                    try:\n                        whiteboard.append_text_box(TextBox(**action_to_update_textbox[\"params\"]))\n                    except UnboundLocalError:\n                        print('Something unexpected happened. A textbox update may have failed')\n\n    def delete_char_from_text(self, whiteboard):\n        \"\"\"\n        efface le dernier caractere du texte\n        \"\"\"\n\n        id_counter = whiteboard.active_box.id_counter\n        for action in [x for x in whiteboard.get_hist('actions') if x['type'] == 'Text_box']:\n            if action['id'] == id_counter:\n                if action['owner'] in whiteboard.modification_allowed or action['owner'] == whiteboard.name:\n                    self._text = self._text[:-1]\n                    action['params'][\"text\"] = whiteboard.active_box.get_textbox_text()\n                    now = datetime.now()\n                    timestamp = datetime.timestamp(now)\n                    action['timestamp'] = timestamp\n                    action['client'] = whiteboard.name\n                    action_to_update_textbox = action\n        for textbox in whiteboard.get_text_boxes():\n            if textbox.id_counter == id_counter:\n                if action['owner'] in whiteboard.modification_allowed or action['owner'] == whiteboard.name:\n                    whiteboard.del_text_box(textbox)\n                    try:\n                        whiteboard.append_text_box(TextBox(**action_to_update_textbox[\"params\"]))\n                    except UnboundLocalError:\n                        print('Something unexpected happened. A textbox update may have failed')\n\n    def render_font(self, text, color, antialias=True):\n        \"\"\"\n        effectue le rendu du texte\n        \"\"\"\n        return self._sysfont.render(text, antialias, color)\n\n    def set_txt_surface(self, value):\n        self._txt_surface = value\n\n    @property\n    def rect(self):\n        return self.__rect\n\n    def update(self):\n        \"\"\"\n        Change la taille du rectangle de contour si le texte est trop long\n        \"\"\"\n        width = max(140, self._txt_surface.get_width() + 20)\n        self.__rect.w = width\n        return width\n\n    def draw(self, screen):\n        \"\"\"\n        dessine la textbox\n        \"\"\"\n        # Blit le texte\n        screen.blit(self._txt_surface, (self.__rect.x + 5, self.__rect.y + 5))\n        # Blit le rectangle\n        pygame.draw.rect(screen, self._color, self.__rect, 2)\n\n\n# =============================================================================\n# fonction de dessins instantanees\n# =============================================================================\n\ndef draw_point(params, screen):\n    \"\"\"\n    dessine un point sur l'ecran avec les parametres d entree\n    params (dict) : dictionnaires des parametres\n    screen (pygame screen) : ecran sur lequel dessiner\n    \"\"\"\n    try:\n        return Point(**params).draw(screen)\n    except TypeError:\n        return \"Parametres incorrect\"\n\n\ndef draw_line(params, screen):\n    \"\"\"\n    dessine une ligne sur l'ecran avec les parametres d entree\n    params (dict) : dictionnaires des parametres\n    screen (pygame screen) : ecran sur lequel dessiner\n    \"\"\"\n    try:\n        return Line(**params).draw(screen)\n    except TypeError:\n        return \"Parametres incorrect\"\n\n\ndef draw_textbox(params, screen):\n    \"\"\"\n    dessine une textbox sur l'ecran avec les parametres d entree\n    params (dict) : dictionnaires des parametres\n    screen (pygame screen) : ecran sur lequel dessiner\n    \"\"\"\n    try:\n        return TextBox(**params).draw(screen)\n    except TypeError:\n        return \"Parametres incorrect\"\n\n\ndef draw_rect(params, screen):\n    \"\"\"\n    dessine un rectangle sur l'ecran avec les parametres d entree\n    params (dict) : dictionnaires des parametres\n    screen (pygame screen) : ecran sur lequel dessiner\n    \"\"\"\n    try:\n        return Rectangle(**params).draw(screen)\n    except TypeError:\n        return \"Parametres incorrect\"\n\n\ndef draw_circle(params, screen):\n    \"\"\"\n    dessine un cercle sur l'ecran avec les parametres d entree\n    params (dict) : dictionnaires des parametres\n    screen (pygame screen) : ecran sur lequel dessiner\n    \"\"\"\n    try:\n        return Circle(**params).draw(screen)\n    except TypeError:\n        return \"Parametres incorrect\"\n"}, {"blob_id": "3e0775bb779ad1a835a157c1667f12eef2205d0f", "path": "/src/client.py", "content_id": "1d52ac4285d3d207db7df6ed5ed0d0f8011eeb97", "language": "Python", "length_bytes": 2197, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7078548669815063, "alpha_fraction": 0.700505256652832, "num_lines": 62, "avg_line_length": 34.1129035949707, "max_line_length": 120, "content": "import socket\nimport json\nimport sys\nimport math\nfrom white_board import WhiteBoard, binary_to_dict\n\n'''\nOuverture de la configuration initiale stock\u00e9e dans config.json qui contient le mode d'\u00e9criture, la couleur et\n la taille d'\u00e9criture. \nCes Param\u00e8tres sont ensuite \u00e0 modifier par l'utisateur dans l'interface pygame\n'''\n\nwith open('config.json') as json_file:\n    start_config = json.load(json_file)\n\n'''\nd\u00e9finition de l'adresse IP du serveur. Ici le serveur est en local.\n'''\nhote = start_config[\"ip_serveur\"]\n\nport = 5001\n\n\ndef main():\n    \"\"\"\n    Cr\u00e9ation d'un socket pour communiquer via un protocole TCP/IP\n    \"\"\"\n    connexion_avec_serveur = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # Connexion au serveur\n    try:\n        connexion_avec_serveur.connect((hote, port))\n    except (TimeoutError, ConnectionRefusedError, ConnectionResetError, ConnectionAbortedError) as e:\n        return print(\"Le serveur n'a pas r\u00e9pondu, v\u00e9rifiez les param\u00e8tres de connexion\")\n    print(\"Connexion r\u00e9ussie avec le serveur\")\n\n    # First get the client id\n    username = binary_to_dict(connexion_avec_serveur.recv(2 ** 16))[\"client_id\"]\n\n    # Second get the message size\n    msg_recu = connexion_avec_serveur.recv(2 ** 8)\n    message_size = binary_to_dict(msg_recu)[\"message_size\"]\n\n    # Then get the first chunk of history using the number of byte equal to the power of 2 just above its size\n    msg_recu = connexion_avec_serveur.recv(2 ** int(math.log(message_size, 2) + 1))\n    total_size_received = sys.getsizeof(msg_recu)\n\n    # One we get the first chunk, we loop until we get the whole history\n    while total_size_received < message_size:\n        msg_recu += connexion_avec_serveur.recv(2 ** int(math.log(message_size, 2) + 1))\n\n        total_size_received = sys.getsizeof(msg_recu)\n    msg_decode = binary_to_dict(msg_recu)\n    hist = msg_decode\n\n    # Apr\u00e8s r\u00e9ception de l'\u00e9tat du whiteboard, c'est \u00e0 dire des figures et textboxes d\u00e9j\u00e0 dessin\u00e9es par des utilisateurs\n    # pr\u00e9c\u00e9dents, le programme lance un whiteboard\n    whiteboard = WhiteBoard(username, start_config, hist)\n    whiteboard.start(connexion_avec_serveur)\n\n\nif __name__ == '__main__':\n    main()\n"}, {"blob_id": "84c672530304edf46530154a97d2507f4121b6d3", "path": "/src/main.py", "content_id": "5bce6202f5e35fb69b18201faa9cd5ccd25dd329", "language": "Python", "length_bytes": 306, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6470588445663452, "alpha_fraction": 0.6470588445663452, "num_lines": 18, "avg_line_length": 16.0, "max_line_length": 46, "content": "from white_board import WhiteBoard\nimport json\n\n'''\nThis file is used to run locally or to debug\n'''\n\nwith open('config.json') as json_file:\n    start_config = json.load(json_file)\n\n\ndef main():\n    board = WhiteBoard(\"client\", start_config)\n    board.start_local()\n\n\nif __name__ == '__main__':\n    main()\n"}, {"blob_id": "4a105eb68c1dcc34d8640b6bc05ed1d2774dc24d", "path": "/src/serveur.py", "content_id": "c3cc53c862262186dc7bd9a83b620acafbf001a9", "language": "Python", "length_bytes": 9673, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6093294620513916, "alpha_fraction": 0.6065180897712708, "num_lines": 252, "avg_line_length": 37.11111068725586, "max_line_length": 119, "content": "import socket\nimport sys\nimport time\nfrom threading import Thread\nimport json\n\n'''\nLes deux fonctions fonctions suivantes permettent de convertir les dictionnaires en binaire et r\u00e9ciproquement.\nL'appel de ces dux fonctions permet d'\u00e9changer des dictionnaires par socket\n'''\n\n\ndef dict_to_binary(dico):\n    try:\n        str = json.dumps(dico)\n        return bytes(str, 'utf-8')\n    except TypeError:\n        print(\"Le dictionnaire n'est pas du format attendu\")\n\n\ndef binary_to_dict(binary):\n    try:\n        jsn = ''.join(binary.decode(\"utf-8\"))\n        d = json.loads(jsn)\n    except (TypeError, json.decoder.JSONDecodeError) as e:\n        if e == TypeError:\n            print(\"Le message re\u00e7u n'est pas du format attendu\")\n        else:\n            print(\"Un paquet a \u00e9t\u00e9 perdu\")\n        return {\"actions\": [], \"message\": [], \"auth\": []}\n    return d\n\n\nclass Client(Thread):\n    \"\"\"\n    Classe d'un client qui se connecte au whiteboard. Cette classe h\u00e9rite de Thread de sorte que plusieurs clients\n    pourront utiliser le whiteboard en parall\u00e8le.\n    Chaque client a un nom, un booleen qui indique si le client a termin\u00e9 d'utiliser le whiteboard,\n    ainsi qu'un historique avec toutes les op\u00e9rations effectu\u00e9es par lui ou les autres utilisateurs sur le whiteboard.\n    C'est cet historique que le client va \u00e9changer avec le serveur\n    \"\"\"\n\n    # Class level id for client\n    client_id = 1\n\n    def __init__(self, server_, client_socket=None):\n        Thread.__init__(self)\n        self._client_socket = client_socket\n        self._done = False\n        self._last_timestamp_sent = 0\n        self.server = server_\n\n        # Increment client id at each creation of instance\n        self.client_id = \"Client\" + str(Client.client_id)\n        Client.client_id += 1\n\n    \"\"\"Encapsulation\"\"\"\n\n    def __get_client_socket(self):\n        return self._client_socket\n\n    def __set_client_socket(self, c):\n        self._client_socket = c\n\n    client_socket = property(__get_client_socket, __set_client_socket)\n\n    def __get_last_timestamp_sent(self):\n        return self._last_timestamp_sent\n\n    def __set_last_timestamp_sent(self, c):\n        self._last_timestamp_sent = c\n\n    last_timestamp_sent = property(__get_last_timestamp_sent, __set_last_timestamp_sent)\n\n    def is_done(self):\n        return self._done\n\n    def end(self):\n        self._done = True\n\n    def check_match(self, action):\n        \"\"\"\n        methode permettant de v\u00e9rifier si une action est d\u00e9j\u00e0 existante dans l'objet self._current_hist.\n        Elle permet notamment de savoir si une textbox vient d'\u00eatre rajout\u00e9e par un autre utilisateur du whiteboard ou\n         si la textbox a simplement \u00e9t\u00e9 mise \u00e0 jour\n        \"\"\"\n        for textbox in [x for x in self.server.historique[\"actions\"] if x[\"type\"] == \"Text_box\"]:\n            if action[\"id\"] == textbox[\"id\"]:\n                textbox[\"timestamp\"] = action[\"timestamp\"]\n                textbox[\"params\"] = action[\"params\"]\n                textbox[\"client\"] = action[\"client\"]\n                return True\n        return False\n\n    def disconnect_client(self):\n        \"\"\"\n        methode s'executant pour mettre fin \u00e0 la connexion entre le serveur et un client\n        \"\"\"\n        self.end()\n        print(\"D\u00e9connexion d'un client\")\n        self.server.historique[\"message\"] = \"end\"\n\n    def run(self):\n        \"\"\"\n        Dans cette methode, la boucle while centrale vient en continu r\u00e9cup\u00e9rer les dictionnaires d'historiques envoy\u00e9s\n         par les clients.\n        Si le dictionnaire est diff\u00e9rent du pr\u00e9c\u00e9dent, cela signifie qu'une mise \u00e0 jour a \u00e9t\u00e9 faite par un utilisateur.\n        Il convient alors de comparer le timestamp de ces mises \u00e0 jour au last_timestamp qui est le dernier timestamp\n         o\u00f9 le whiboard \u00e9tait \u00e0 jour.\n        Toutes les nouvelles op\u00e9rations sont ensuite envoy\u00e9es au client\n        \"\"\"\n        try:\n            while not self.is_done():\n                msg_recu = self.client_socket.recv(2 ** 24)\n                new_actions = binary_to_dict(msg_recu)\n\n                # Go through each new action and add them to history and there are two cases : if it's an action on\n                # an already existing text box then modify it in history, else append the action to the history\n                for action in new_actions[\"actions\"]:\n                    matched = False\n                    if action[\"type\"] == \"Text_box\":\n                        matched = self.check_match(action)\n                    if not matched:\n                        self.server.historique[\"actions\"].append(action)\n                if self.server.historique[\"message\"] == \"END\":\n                    # S'\u00e9x\u00e9cute si le client se d\u00e9connecte\n                    self.disconnect_client()\n                if new_actions[\"auth\"] != []:\n                    if new_actions[\"auth\"][1]:\n                        self.server.historique[\"auth\"].append(new_actions[\"auth\"][0])\n                    else:\n                        self.server.historique[\"auth\"].remove(new_actions[\"auth\"][0])\n                time.sleep(0.01)\n                actions_to_send = [x for x in self.server.historique[\"actions\"] if\n                                   (x[\"timestamp\"] > self.last_timestamp_sent and x[\"client\"] != self.client_id)]\n                to_send = {\"message\": \"\", 'actions': actions_to_send, 'auth': self.server.historique[\"auth\"]}\n                self.client_socket.send(dict_to_binary(to_send))\n\n                # Update last timestamp if there is a new action\n                if actions_to_send:\n                    self.last_timestamp_sent = max([x[\"timestamp\"] for x in actions_to_send])\n        except (ConnectionAbortedError, ConnectionResetError) as e:\n            # G\u00e8re la d\u00e9connexion soudaine d'un client\n            print(\"Un client s'est d\u00e9connect\u00e9\")\n\n\nclass Server:\n    \"\"\"\n    Cette classe d\u00e9finit un serveur.\n    Elle a pour param\u00e8tres un port et une adresse h\u00f4te n\u00e9cessaire \u00e0 la cr\u00e9ation d'une connexion,\n    \u00e9galement une connexion socket propre au serveur,\n    ainsi qu'une liste des clients \u00e0 connecter,\n    une liste des threads lanc\u00e9s qui est la liste des clients actuellement connect\u00e9s\n    et un dictionnaire historique des op\u00e9rations faites sur le serveur \u00e0 \u00e9changer avec les diff\u00e9rents clients\n    \"\"\"\n\n    def __init__(self, port, host='', historique=None):\n        self._host = host\n        self._port = port\n        self.__connexion = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.__clients = []\n        self.__threadlaunched = []\n        if historique is None:\n            self.historique = {\"message\": \"\", 'actions': [], 'auth': []}\n        else:\n            self.historique = historique\n\n    '''Les m\u00e9thodes et properties suivantes permettent de g\u00e9rer les encapsulations'''\n\n    @property\n    def host(self):\n        return self._host\n\n    @property\n    def port(self):\n        return self._port\n\n    @property\n    def clients(self):\n        return self.__clients\n\n    def add_client(self, new_client):\n        self.__clients.append(new_client)\n\n    def remove_client(self, client_removed):\n        self.__clients.remove(client_removed)\n\n    @property\n    def threadlaunched(self):\n        return self.__threadlaunched\n\n    def add_thread(self, new_thread):\n        self.__threadlaunched.append(new_thread)\n\n    def remove_thread(self, thread_removed):\n        self.__threadlaunched.remove(thread_removed)\n\n    def scan_new_client(self):\n        \"\"\"Cette m\u00e9thode permet de r\u00e9cup\u00e9rer les informations du client entrant\"\"\"\n        # Get connexion info from server\n        client, infos_connexion = self.__connexion.accept()\n\n        # Initialize a new client thread\n        new_thread = Client(self)\n\n        # Give them an id and send it to server\n        client_id = new_thread.client_id\n        client.send(dict_to_binary({\"client_id\": client_id}))\n\n        to_send = dict_to_binary(self.historique)\n        # Get the size of history and send it because it can be too long\n        message_size = sys.getsizeof(to_send)\n        client.send(dict_to_binary({\"message_size\": message_size}))\n\n        # Wait a little for the previous message to not overlap with the next one\n        ## !!WARNING!! DEPENDING ON THE COMPUTER THIS SLEEP TIME MAY BE TOO SMALL, IF THE WHITEBOARD CRASHES, PLEASE\n        ## INCREASE IT\n        time.sleep(0.5)\n        client.send(to_send)\n        # Get the last timestamp sent to client\n        try:\n            new_thread.last_timestamp_sent = max([x[\"timestamp\"] for x in self.historique[\"actions\"]])\n        except ValueError:\n            new_thread.last_timestamp_sent = 0\n        new_thread.client_socket = client\n        self.add_client(new_thread)\n        print(\"Un client s'est connect\u00e9. Bienvenue {} !\".format(client_id))\n\n    def run(self):\n        \"\"\"\n        Dans cette m\u00e9thode, la boucle while permet d'\u00e9couter en permanence de nouveaux clients potentiels\n        et de g\u00e9rer les d\u00e9connexions de clients et fermetures de thread\"\"\"\n        self.__connexion.bind((self.host, self.port))\n\n        # Le serveur acceptera maximum 100 clients\n        self.__connexion.listen(100)\n        print(\"Le serveur est pr\u00eat sur le port num\u00e9ro {}\".format(self.port))\n        while True:\n            self.scan_new_client()\n            for client in self.clients:\n                client.start()\n                self.remove_client(client)\n                self.add_thread(client)\n            for thread in self.threadlaunched:\n                if thread.is_done():\n                    thread.join()\n                    self.remove_thread(thread)\n\n\nif __name__ == '__main__':\n    server = Server(5001, '')\n    server.run()\n"}, {"blob_id": "aaa6aa43c8b97aaa86685f74eabffe1fd9f11c5b", "path": "/src/tools.py", "content_id": "41c5aff1c48b63832220b0d30090ee9f39d51059", "language": "Python", "length_bytes": 15962, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5647486448287964, "alpha_fraction": 0.5584179759025574, "num_lines": 431, "avg_line_length": 36.01624298095703, "max_line_length": 116, "content": "\"\"\"\nModule contenant les differents outils de gestion du tableau\n\"\"\"\nimport pygame\nimport pygame.draw\nfrom datetime import datetime\nfrom figures import Point, Line, TextBox, Rectangle, Circle\nimport time\n\n\n# =============================================================================\n# classes de gestion des changements de parametres utilisateur\n# =============================================================================\n\nclass TriggerBox:\n    \"\"\"\n    Classe mere abstraite qui represente une zone carree de l'ecran sur laquelle on peut cliquer\n    top_left (list) : coordonees du pixel en haut a gauche\n    size (int) : taille en pixel du cote du carre\n    \"\"\"\n\n    def __init__(self, top_left, size):\n        self.rect = pygame.Rect(top_left, size)\n        self.coords = top_left\n\n    def is_triggered(self, event):\n        \"\"\"\n        retourne le booleen : l'utilisateur clique sur la triggerbox\n        event (pygame event) : clic de souris d un utilisateur\n        \"\"\"\n        return self.rect.collidepoint(event.pos)\n\n\nclass Auth(TriggerBox):\n    \"\"\"\n    Classe d'un bouton qui change l'autorisation de modification\n    \"\"\"\n\n    def __init__(self, top_left, size):\n        TriggerBox.__init__(self, top_left, size)\n        self._size = size\n\n    def add(self, screen):\n        \"\"\"\n        Dessine la authbox\n        \"\"\"\n        pygame.draw.rect(screen, [0, 0, 0], self.rect, 1)\n        pygame.draw.circle(screen, [255, 0, 0],\n                           [int(self.coords[0] + self._size[0] / 2), int(self.coords[1] + self._size[1] / 2)],\n                           int(min(self._size[0], self._size[1] / 3)))\n        font = pygame.font.Font(None, 18)\n        legend = {\"text\": font.render(\"auth\", True, [0, 0, 0]), \"coords\": self.coords}\n        screen.blit(legend[\"text\"], legend[\"coords\"])\n\n    def switch(self, screen, erasing_auth, modification_allowed, name):\n        if erasing_auth:\n            pygame.draw.circle(screen, [0, 255, 0],\n                               [int(self.coords[0] + self._size[0] / 2), int(self.coords[1] + self._size[1] / 2)],\n                               int(min(self._size[0], self._size[1] / 3)))\n            print(\"{} a donn\u00e9 son autorisation de modifications\".format(name))\n\n        else:\n            pygame.draw.circle(screen, [255, 0, 0],\n                               [int(self.coords[0] + self._size[0] / 2), int(self.coords[1] + self._size[1] / 2)],\n                               int(min(self._size[0], self._size[1] / 3)))\n            print(\"{} a retir\u00e9 son autorisation de modifications\".format(name))\n        return [name, erasing_auth]\n\n\nclass Save(TriggerBox):\n    \"\"\"\n    Classe d'un bouton qui permet la sauvegarde du whiteboard en format PNG\n    \"\"\"\n\n    def __init__(self, top_left, size):\n        TriggerBox.__init__(self, top_left, size)\n        self._size = size\n\n    def add(self, screen):\n        \"\"\"\n        Dessine la savebox\n        \"\"\"\n        pygame.draw.rect(screen, [0, 0, 0], self.rect, 1)\n        font = pygame.font.Font(None, 18)\n        legend = {\"text\": font.render(\"save\", True, [0, 0, 0]), \"coords\": self.coords}\n        screen.blit(legend[\"text\"], legend[\"coords\"])\n\n    def save(self, screen, whiteboard):\n        pygame.image.save(screen.subsurface((0, whiteboard.get_config([\"toolbar_y\"]) + 1,\n                                             whiteboard.get_config([\"width\"]),\n                                             whiteboard.get_config([\"length\"]) - whiteboard.get_config(\n                                                 [\"toolbar_y\"]) - 1)), \"mygreatdrawing.png\")\n\n\nclass Mode(TriggerBox):\n    \"\"\"\n    Classe d'un mode de dessin du tableau dans lequel on peut rentrer via la triggerbox dont il herite\n    name (string) : nom du mode qui sera inscrit dans sa triggerbox sur l'ecran\n    \"\"\"\n\n    def __init__(self, name, top_left, size):\n        super(Mode, self).__init__(top_left, size)\n        self.name = name\n\n    def add(self, screen):\n        \"\"\"\n        Dessine la triggerbox du mode et la rend active sur l'ecran\n        \"\"\"\n        pygame.draw.rect(screen, [0, 0, 0], self.rect, 1)\n        font = pygame.font.Font(None, 18)\n        legend = {\"text\": font.render(self.name, True, [0, 0, 0]), \"coords\": self.coords}\n        screen.blit(legend[\"text\"], legend[\"coords\"])\n\n\nclass ColorBox(TriggerBox):\n    \"\"\"\n    Classe d'une triggerbox de choix de couleur sur l'ecran\n    color (list) : color of the box\n    \"\"\"\n\n    def __init__(self, color, top_left, size):\n        super(ColorBox, self).__init__(top_left, size)\n        self.color = color\n\n    def add(self, screen):\n        \"\"\"\n        Dessine la colorbox\n        \"\"\"\n        pygame.draw.rect(screen, self.color, self.rect)\n\n\nclass FontSizeBox(TriggerBox):\n    \"\"\"\n    Classe des triggerbox de choix de l'epaisseur du trait\n    font_size (int) : epaisseur du trait en pixel\n    \"\"\"\n\n    def __init__(self, font_size, top_left, size):\n        super(FontSizeBox, self).__init__(top_left, size)\n        self.font_size = font_size\n        self.center = [top_left[0] + size[0] // 2,\n                       top_left[1] + size[1] // 2]  # pour dessiner un cercle representant l epaisseur de selection\n\n    def add(self, screen):\n        \"\"\"\n        Dessine la fontsizebox\n        \"\"\"\n        pygame.draw.rect(screen, [0, 0, 0], self.rect, 1)\n        pygame.draw.circle(screen, [0, 0, 0], self.center, self.font_size)\n\n\n# =============================================================================\n# classes de gestion des evenements utilisateur\n# =============================================================================\n\nclass EventHandler:\n    \"\"\"\n    Classe mere des gestionnaires d'evenements utilisateur en fontcion des modes\n    whiteboard : classe whiteboard sur laquelle notre handler va gerer les evenements utilisateur\n    \"\"\"\n\n    def __init__(self, whiteboard):\n        self.whiteboard = whiteboard\n\n    def handle(self, event):\n        \"\"\"\n        Ce test commun a tous les modes verifie si l'utilisateur quitte ou change de mode\n        \"\"\"\n        out = False\n        if event.type == pygame.QUIT:\n            self.whiteboard.end()\n            self.whiteboard.switch_config(\"quit\")\n            out = True\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            coord = event.dict['pos']\n            if coord[1] <= self.whiteboard.get_config([\"toolbar_y\"]):\n                self.whiteboard.switch_config(event)\n                out = True\n        return out\n\n\nclass HandlePoint(EventHandler):\n    \"\"\"\n    Classe du gestionnaire d'evenement en mode point\n    \"\"\"\n\n    def __init__(self, whiteboard):\n        EventHandler.__init__(self, whiteboard)\n\n    def handle_all(self, event):\n        \"\"\"\n        En mode point on s'interesse aux clics gauches de souris et on dessine un point\n        \"\"\"\n        handled = self.handle(event)\n\n        # commun a tous les handler qui verifie si on change de mode ou on quitte\n        if handled:\n            return\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            if event.dict[\"button\"] != 1:\n                return\n            coord = event.dict[\"pos\"]\n            to_draw = Point(coord,\n                            self.whiteboard.get_config([\"active_color\"]),\n                            self.whiteboard.get_config([\"font_size\"]), self.whiteboard.get_config([\"toolbar_y\"]))\n            now = datetime.now()\n            timestamp = datetime.timestamp(now)\n            self.whiteboard.draw(to_draw, timestamp)\n\n\nclass HandleLine(EventHandler):\n    \"\"\"\n    Classe du gestionnaire d'evenement en mode ligne\n    \"\"\"\n\n    def __init__(self, whiteboard):\n        EventHandler.__init__(self, whiteboard)\n\n    def handle_mouse_motion(self):\n        \"\"\"\n        Gere les mouvements de souris : l'utilisateur a le clic enfonce le rendu du trait est en direct\n        \"\"\"\n        if self.whiteboard.is_drawing():\n            self.whiteboard.mouse_position = pygame.mouse.get_pos()\n            if self.whiteboard.mouse_position[1] <= self.whiteboard.get_config([\"toolbar_y\"]):\n                self.whiteboard.pen_up()\n            elif self.whiteboard.last_pos is not None:\n                to_draw = Line(self.whiteboard.get_config([\"active_color\"]), self.whiteboard.last_pos,\n                               self.whiteboard.mouse_position,\n                               self.whiteboard.get_config([\"font_size\"]))\n                now = datetime.now()\n                timestamp = datetime.timestamp(now)\n                self.whiteboard.draw(to_draw, timestamp)\n            self.whiteboard.update_last_pos()\n\n    def handle_mouse_button_up(self):\n        \"\"\"\n        Gere la levee du doigt sur le clic : on effectue un pen up\n        \"\"\"\n        self.whiteboard.mouse_position = (0, 0)\n        self.whiteboard.pen_up()\n        self.whiteboard.reset_last_pos()\n\n    def handle_mouse_button_down(self):\n        \"\"\"\n        Gere le clic de l'utilisateur : pen down\n        \"\"\"\n        self.whiteboard.pen_down()\n\n    def handle_all(self, event):\n        \"\"\"\n        Gere tous les evenements avec la methode associe via un arbre de if\n        \"\"\"\n        handled = self.handle(event)\n        if handled:\n            return\n        elif event.type == pygame.MOUSEMOTION:\n            self.handle_mouse_motion()\n        elif event.type == pygame.MOUSEBUTTONUP:\n            self.handle_mouse_button_up()\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            self.handle_mouse_button_down()\n        pygame.display.flip()\n\n\nclass HandleText(EventHandler):\n    \"\"\"\n    Classe du gestionnaire d'evenement en mode textbox\n    \"\"\"\n\n    def __init__(self, whiteboard):\n        EventHandler.__init__(self, whiteboard)\n\n    def box_selection(self, event):\n        \"\"\"\n        Gere les clics utilisateur\n        S'il s'agit d'un clic droit, on cree une nouvelle box\n        S'il s'agit d'un clic gauche on regarde si cela selectionne une zone d une ancienne box qui deviendra la box\n         active\n        \"\"\"\n        if event.dict[\"button\"] == 3:\n            coord = event.dict['pos']\n            text_box = TextBox(*coord, self.whiteboard.get_config([\"text_box\", \"textbox_width\"]),\n                               self.whiteboard.get_config([\"text_box\", \"textbox_length\"]),\n                               self.whiteboard.get_config([\"text_box\", \"active_color\"]),\n                               self.whiteboard.get_config([\"text_box\", \"font\"]),\n                               self.whiteboard.get_config([\"text_box\", \"font_size\"]), \"\",\n                               self.whiteboard.get_config([\"active_color\"]))\n            self.whiteboard.append_text_box(text_box)\n            now = datetime.now()\n            timestamp = datetime.timestamp(now)\n            self.whiteboard.draw(text_box, timestamp)\n            self.whiteboard.set_active_box(text_box)\n\n        elif event.dict[\"button\"] == 1:\n            for box in self.whiteboard.get_text_boxes():\n                if box.rect.collidepoint(event.pos):\n                    self.whiteboard.set_active_box(box, new=False)\n\n    def write_in_box(self, event):\n        \"\"\"\n        Gere les entrees clavier de l'utilisateur\n        Si une box est selectionnee cela modifie le texte en consequence\n        \"\"\"\n        if self.whiteboard.active_box is not None:\n\n            # on efface un caractere\n            if event.key == pygame.K_BACKSPACE:\n                self.whiteboard.active_box.delete_char_from_text(self.whiteboard)\n\n                # pour modifier la box il est malheureusement necessaire de re-render tout le tableau\n                self.whiteboard.clear_screen()\n                self.whiteboard.load_actions(self.whiteboard.get_hist())\n            elif event.key == pygame.K_TAB or event.key == pygame.K_RETURN:\n                pass\n            else:\n                self.whiteboard.active_box.add_character_to_text(event.unicode, self.whiteboard)\n\n                # on re-render tout aussi ici pour \u00e9viter de superposer des \u00e9critures\n                self.whiteboard.clear_screen()\n                self.whiteboard.load_actions(self.whiteboard.get_hist())\n\n        if self.whiteboard.active_box is not None:\n            # Re-render the text.\n            self.whiteboard.active_box.set_txt_surface(self.whiteboard.active_box.render_font(\n                self.whiteboard.active_box.get_textbox_text(),\n                self.whiteboard.active_box.get_textbox_color()))\n\n    def handle_all(self, event):\n        \"\"\"\n        Gere tous les evenements avec la methode associ\u00e9e via un arbre de if\n        \"\"\"\n        handled = self.handle(event)\n        if handled:\n            return\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            self.box_selection(event)\n        if event.type == pygame.KEYDOWN:\n            self.write_in_box(event)\n        pygame.display.flip()\n\n\nclass HandleRect(EventHandler):\n    \"\"\"\n    Classe du gestionnaire d'evenement en mode rectangle\n    Nous avons decid\u00e9 de faire un systeme de clic drag pour tracer un rectangle\n    \"\"\"\n\n    def __init__(self, whiteboard):\n        EventHandler.__init__(self, whiteboard)\n        self.c1 = None\n\n    def handle_mouse_button_up(self, coord):\n        \"\"\"\n        Recupere la deuxieme coordonee d'un coin du rectangle a tracer quand l'utilisateur arrete de cliquer\n        \"\"\"\n        if self.c1 is not None:\n            coord = list(coord)\n            # on ne veut pas depasser sur la toolbar\n            coord[1] = max(self.whiteboard.get_config([\"toolbar_y\"]), coord[1])\n            to_draw = Rectangle(self.c1, coord, self.whiteboard.get_config([\"active_color\"]))\n            now = datetime.now()\n            timestamp = datetime.timestamp(now)\n            self.whiteboard.draw(to_draw, timestamp)\n            self.c1 = None\n\n    def handle_mouse_button_down(self, event):\n        \"\"\"\n        Recupere une coordonee d'un coin du rectangle a tracer quand l'utilisateur d\u00e9marre un clic\n        \"\"\"\n        if event.dict[\"button\"] != 1:\n            return\n        self.c1 = event.dict['pos']\n\n    def handle_all(self, event):\n        \"\"\"\n        Gere tous les evenements avec la methode associe via un arbre de if\n        \"\"\"\n        handled = self.handle(event)\n        if handled:\n            return\n        elif event.type == pygame.MOUSEBUTTONUP:\n            self.handle_mouse_button_up(coord=event.dict['pos'])\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            self.handle_mouse_button_down(event)\n        pygame.display.flip()\n\n\nclass HandleCircle(EventHandler):\n    \"\"\"\n    Classe du gestionnaire d'evenement en mode Cercle\n    Nous avons decid\u00e9 de faire un systeme de clic drag la-encore pour tracer un cercle\n    \"\"\"\n\n    def __init__(self, whiteboard):\n        EventHandler.__init__(self, whiteboard)\n        self.center = None\n\n    def handle_mouse_button_up(self, coord):\n        \"\"\"\n        Recupere la coordonee d'un point sur le cercle quand l'utilisateur arrete de cliquer\n        \"\"\"\n        if self.center is not None:\n            coord = list(coord)\n            to_draw = Circle(self.center, coord, self.whiteboard.get_config([\"active_color\"]),\n                             self.whiteboard.get_config([\"toolbar_y\"]))\n            now = datetime.now()\n            timestamp = datetime.timestamp(now)\n            self.whiteboard.draw(to_draw, timestamp)\n            self.center = None\n\n    def handle_mouse_button_down(self, event):\n        \"\"\"\n        Recupere la coordonnee du centre du cercle quand l'utilisateur demarre un clic\n        \"\"\"\n        if event.dict[\"button\"] != 1:\n            return\n        self.center = event.dict['pos']\n\n    def handle_all(self, event):\n        \"\"\"\n        Gere tous les evenements avec la methode associe via un arbre de if\n        \"\"\"\n        handled = self.handle(event)\n        if handled:\n            return\n        elif event.type == pygame.MOUSEBUTTONUP:\n            self.handle_mouse_button_up(coord=event.dict['pos'])\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            self.handle_mouse_button_down(event)\n        pygame.display.flip()\n"}, {"blob_id": "ce182a1f3ba0425a0daaecf61fb644c0b2dd80e5", "path": "/requirements.txt", "content_id": "20e9e212c9976ba7b8d0f94a9b634f5c41889cba", "language": "Text", "length_bytes": 71, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.8732394576072693, "alpha_fraction": 0.8732394576072693, "num_lines": 8, "avg_line_length": 8.0, "max_line_length": 11}, {"blob_id": "84a2e1eae878c3a8e2017a1caa936481a1649c1b", "path": "/src/white_board.py", "content_id": "c06c4f1ef0818ed8dd6689f9b19834bb82df5b71", "language": "Python", "length_bytes": 21052, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.5422568917274475, "alpha_fraction": 0.5400703549385071, "num_lines": 515, "avg_line_length": 39.850486755371094, "max_line_length": 120, "content": "import pygame\nimport pygame.draw\nimport json\nimport sys\nfrom functools import reduce\nimport operator\nfrom figures import TextBox, draw_line, draw_point, draw_textbox, draw_rect, draw_circle\nfrom tools import Mode, ColorBox, Auth, Save, FontSizeBox, HandlePoint, HandleLine, HandleText, HandleRect, HandleCircle\nimport copy\n\n'''\nOuverture de la configuration initiale\n'''\n\n\ndef dict_to_binary(the_dict):\n    str = json.dumps(the_dict)\n    return bytes(str, 'utf-8')\n\n\ndef binary_to_dict(binary):\n    try:\n        jsn = ''.join(binary.decode(\"utf-8\"))\n        d = json.loads(jsn)\n    except (TypeError, json.decoder.JSONDecodeError) as e:\n        if e == TypeError:\n            print(\"Le message re\u00e7u n'est pas du format attendu\")\n        else:\n            print('Un paquet a \u00e9t\u00e9 perdu')\n        return {\"actions\": [], \"message\": [], \"auth\": []}\n    return d\n\n\nclass WhiteBoard:\n    def __init__(self, client_name, start_config, start_hist=None):\n        \"\"\"\n        Whiteboard initialization : we build the GUI using the config file and the potential history of actions made by\n         other users. Returns a Whiteboard window ready to use.\n\n        :param client_name: Name of the client who just opened a new whiteboard window (str)\n        :param start_config: Whiteboard configuration stored in config.json and loaded as a dict (dict)\n        :param start_hist: History of actions by other users (dict)\n        \"\"\"\n        pygame.init()\n\n        if not isinstance(client_name, str):\n            raise TypeError(\"Client name must be a string\")\n        if not isinstance(start_config, dict):\n            raise TypeError(\"Starting configuration file must be a dictionary\")\n        if start_hist is None:\n            start_hist = {\"actions\": [], \"message\": [], \"auth\": []}\n        elif not isinstance(start_hist, dict):\n            raise TypeError(\"Starting history file must be a dictionary\")\n\n        self._done = False\n        self._config = start_config\n        self._name = client_name\n        self._hist = start_hist\n        self.__screen = pygame.display.set_mode([self._config[\"width\"], self._config[\"length\"]])\n        self.__screen.fill(self._config[\"board_background_color\"])\n        self.__handler = {\"line\": HandleLine(self),\n                          \"point\": HandlePoint(self),\n                          \"text\": HandleText(self),\n                          \"rect\": HandleRect(self),\n                          \"circle\": HandleCircle(self)}\n\n        pygame.draw.line(self.__screen, self._config[\"active_color\"], [0, self._config[\"toolbar_y\"]],\n                         [self._config[\"width\"], self._config[\"toolbar_y\"]], 1)\n\n        # We create a global variable to keep track of the position of the last mode box we create in order to make\n        # sure that there is no overlapping between left and right boxes on the toolbar on the toolbar\n\n        \"\"\"\n        Trac\u00e9 de la box auth, qui permet de donner l'autorisation de modification des textbox\n        \"\"\"\n\n        last_left_position = 0\n        last_right_position = self._config[\"width\"] - self._config[\"mode_box_size\"][0]\n        self._erasing_auth = False\n\n        try:\n            assert last_left_position < last_right_position + 1, \"Too many tools to fit in the Whiteboard \" \\\n                                                                 \"toolbar, please increase width in config.json\"\n            self.__auth_box = Auth((last_left_position, 0), tuple(self._config[\"auth_box_size\"]))\n            last_left_position += self._config[\"mode_box_size\"][0]\n            self.__auth_box.add(self.__screen)\n        except AssertionError as e:\n            print(e)\n            pygame.quit()\n            sys.exit()\n\n        \"\"\"\n        Trac\u00e9 de la boite save qui permet d'enregistrer l'image\n        \"\"\"\n\n        try:\n            assert last_left_position < last_right_position + 1, \"Too many tools to fit in the Whiteboard \" \\\n                                                                 \"toolbar, please increase width in config.json\"\n            self.__save_box = Save((last_left_position, 0), tuple(self._config[\"auth_box_size\"]))\n            last_left_position += self._config[\"mode_box_size\"][0]\n            self.__save_box.add(self.__screen)\n        except AssertionError as e:\n            print(e)\n            pygame.quit()\n            sys.exit()\n\n        self.__modes = [Mode(\"point\", (2 * self._config[\"mode_box_size\"][0], 0), tuple(self._config[\"mode_box_size\"])),\n                        Mode(\"line\", (3 * self._config[\"mode_box_size\"][0], 0), tuple(self._config[\"mode_box_size\"])),\n                        Mode(\"text\", (4 * self._config[\"mode_box_size\"][0], 0), tuple(self._config[\"mode_box_size\"])),\n                        Mode(\"rect\", (5 * self._config[\"mode_box_size\"][0], 0), tuple(self._config[\"mode_box_size\"])),\n                        Mode(\"circle\", (6 * self._config[\"mode_box_size\"][0], 0), tuple(self._config[\"mode_box_size\"]))\n                        ]\n        # If right and left boxes overlap, raise an error and close pygame\n        try:\n            for mod in self.__modes:\n                assert last_left_position < last_right_position + 1, \"Too many tools to fit in the Whiteboard \" \\\n                                                                     \"toolbar, please increase width in config.json\"\n                mod.add(self.__screen)\n                last_left_position += self._config[\"mode_box_size\"][0]\n        except AssertionError as e:\n            print(e)\n            pygame.quit()\n            sys.exit()\n\n        \"\"\"\n        Choix des couleurs\n        \"\"\"\n        self.__colors = []\n        try:\n            for key, value in self._config[\"color_palette\"].items():\n                assert last_left_position < last_right_position + 1, \"Too many tools to fit in the Whiteboard \" \\\n                                                                     \"toolbar, please increase width in config.json\"\n                color_box = ColorBox(value, (last_right_position, 0), tuple(self._config[\"mode_box_size\"]))\n                last_right_position -= self._config[\"mode_box_size\"][0]\n                self.__colors.append(color_box)\n                color_box.add(self.__screen)\n        except AssertionError as e:\n            print(e)\n            pygame.quit()\n            sys.exit()\n\n        \"\"\"\n        Choix des \u00e9paisseurs\n        \"\"\"\n        self.__font_sizes = []\n        try:\n            for size in self._config[\"pen_sizes\"]:\n                assert last_left_position < last_right_position + 1, \"Too many tools to fit in the Whiteboard \" \\\n                                                                     \"toolbar, please increase width in config.json\"\n                font_size_box = FontSizeBox(size, (last_right_position, 0), tuple(self._config[\"mode_box_size\"]))\n                last_right_position -= self._config[\"mode_box_size\"][0]\n                self.__font_sizes.append(font_size_box)\n                font_size_box.add(self.__screen)\n        except AssertionError as e:\n            print(e)\n            pygame.quit()\n            sys.exit()\n\n        \"\"\"\n        initialisation des variables de dessin\n        \"\"\"\n        pygame.display.flip()\n        self._draw = False\n        self._last_pos = None\n        self._mouse_position = (0, 0)\n\n        \"\"\"\n        Initialisation des param\u00e8tres des text boxes\n        \"\"\"\n        self._text_boxes = []  # Cette liste contiendra les objets de type Textbox\n\n        self.active_box = None\n\n        self.load_actions(self._hist)\n        self.__modification_allowed = copy.deepcopy(self._hist[\"auth\"])\n\n        # if some client names are in this list, you will have the authorisation to edit their textboxes\n\n        for action in self._hist[\"actions\"]:\n            if action[\"type\"] == \"Text_box\":\n                self.append_text_box(TextBox(**action[\"params\"]))\n\n    \"\"\"\n    Encapsulation\n    \"\"\"\n\n    def is_done(self):\n        return self._done\n\n    def end(self):\n        self._done = True\n\n    def get_config(self, maplist):\n        \"\"\"\n        Getter of config file. Uses a list of keys to traverse the config dict\n        :param maplist: list of keys from parent to child to get the wanted value (list)\n        :return: value of a key in the config file (object)\n        \"\"\"\n        if not type(maplist) == list:\n            maplist = list(maplist)\n        try:\n            return reduce(operator.getitem, maplist, self._config)\n        except (KeyError, TypeError):\n            return None\n\n    def set_config(self, maplist, value):\n        \"\"\"\n        Setter of config file. Uses the getter and assigns value to a key\n        :param maplist: list of keys from parent to child to get the wanted value (list)\n        :param value: value to set (object)\n        :return: None if failed\n        \"\"\"\n        if not type(maplist) == list:\n            maplist = list(maplist)\n        try:\n            self.get_config(maplist[:-1])[maplist[-1]] = value\n        except (KeyError, TypeError):\n            return None\n\n    def get_hist(self, key=None):\n        if key is None:\n            return self._hist\n        else:\n            return self._hist[key]\n\n    def add_to_hist(self, value):\n        self._hist[\"actions\"].append(value)\n\n    @property\n    def screen(self):\n        return self.__screen\n\n    def clear_screen(self):\n        \"\"\"\n        Clear the screen by coloring it to background color. Does not color the toolbar\n        :return:\n        \"\"\"\n        self.__screen.fill(self.get_config([\"board_background_color\"]), (0, self.get_config([\"toolbar_y\"]) + 1,\n                                                                         self.get_config([\"width\"]),\n                                                                         self.get_config([\"length\"]) - self.get_config(\n                                                                             [\"toolbar_y\"]) + 1))\n\n    def is_drawing(self):\n        return self._draw\n\n    def pen_up(self):\n        self._draw = False\n\n    def pen_down(self):\n        self._draw = True\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def modification_allowed(self):\n        return self.__modification_allowed\n\n    @property\n    def last_pos(self):\n        return self._last_pos\n\n    def reset_last_pos(self):\n        self._last_pos = None\n\n    def update_last_pos(self):\n        self._last_pos = self._mouse_position\n\n    def __get_mouse_position(self):\n        return self._mouse_position\n\n    def __set_mouse_position(self, value):\n        self._mouse_position = value\n\n    mouse_position = property(__get_mouse_position, __set_mouse_position)\n\n    def get_text_boxes(self):\n        return self._text_boxes\n\n    def append_text_box(self, textbox):\n        self._text_boxes.append(textbox)\n\n    def del_text_box(self, textbox):\n        self._text_boxes.remove(textbox)\n\n    def draw(self, obj, timestamp):\n        \"\"\"\n        Method to draw figures defined in figures.py. Also adds drawn objects to history.\n\n        :param obj: class of figure to draw\n        :param timestamp: timestamp at which the drawing happens\n        :return: None\n        \"\"\"\n\n        # Draw object on screen\n        obj.draw(self.__screen)\n\n        # Create dict containing object parameters and right timestamp to add to history\n        hist_obj = {\"type\": obj.type, \"timestamp\": timestamp, \"params\": obj.fetch_params(), \"client\": self._name}\n\n        # Special case if it's a Text_box object, we need to get the correct box id\n        if hist_obj[\"type\"] == \"Text_box\":\n            hist_obj[\"id\"] = obj.id_counter\n            hist_obj[\"owner\"] = self._name\n        self.add_to_hist(hist_obj)\n\n    def switch_config(self, event):\n        \"\"\"\n        Switch between different modes\n\n        :param event: Action by the user : a mouse click on either modes, colors or font sizes\n        :return: None\n        \"\"\"\n        if event == \"quit\":\n            self.set_config([\"mode\"], \"quit\")\n\n        # We go through each mode, color and font size to see if that mode should be triggered by the event\n        else:\n            for mod in self.__modes:\n                if mod.is_triggered(event):\n                    self.set_config([\"mode\"], mod.name)\n            for col in self.__colors:\n                if col.is_triggered(event):\n                    self.set_config([\"text_box\", \"text_color\"], col.color)\n                    self.set_config([\"active_color\"], col.color)\n            for font_size_ in self.__font_sizes:\n                if font_size_.is_triggered(event):\n                    self.set_config([\"font_size\"], font_size_.font_size)\n            if self.__auth_box.is_triggered(event):\n                self._erasing_auth = not self._erasing_auth\n                self.__auth_box.switch(self.__screen, self._erasing_auth, self.__modification_allowed, self._name)\n                self._hist[\"auth\"] = [self._name, self._erasing_auth]\n            if self.__save_box.is_triggered(event):\n                self.__save_box.save(self.__screen, self)\n                print(\"Le dessin a \u00e9t\u00e9 sauvegard\u00e9 dans le dossier\")\n\n    def set_active_box(self, box, new=True):\n        \"\"\"\n        A method specific to text boxes : select an existing box or one that has just been created to edit. This box is\n        thus said to be \"active\"\n\n        :param box: instance of the TextBox class\n        :param new: boolean to specify if the box was just created or already existed\n        :return:\n        \"\"\"\n\n        # If the selected box is already the active one, do nothing\n        if box == self.active_box:\n            return\n\n        # If there is a box that is active we must turn it into \"inactive\"\n        if self.active_box is not None:\n\n            # Change its color to the \"inactive color\"\n            self.active_box.set_textbox_color(self.get_config([\"text_box\", \"inactive_color\"]))\n            # Select the id of previous active box\n            id_counter = self.active_box.id_counter\n            # Find the previous active box and change its color in history\n            for action in [x for x in self.get_hist('actions') if x['type'] == 'Text_box']:\n                if action['id'] == id_counter:\n                    action[\"params\"][\"text\"] = self.active_box.get_textbox_text()\n                    action['params'][\"box_color\"] = self.get_config([\"text_box\", \"inactive_color\"])\n            # Render it\n            self.active_box.draw(self.__screen)\n\n        # If selected box already exists on the whiteboard we must turn it into \"active\"\n        if not new:\n            id_counter = box.id_counter\n            for action in [x for x in self.get_hist('actions') if x['type'] == 'Text_box']:\n                if action['id'] == id_counter:\n                    action['params'][\"box_color\"] = self.get_config([\"text_box\", \"active_color\"])\n\n        # Draw the newly activated box\n        self.active_box = box\n        self.active_box.draw(self.__screen)\n        pygame.display.flip()\n\n    def draw_action(self, action):\n        \"\"\"\n        Draw the result of an action by the user on the whiteboard\n\n        :param action: usually a mouse action by the user\n        :return:\n        \"\"\"\n        if action[\"type\"] == \"Point\":\n            draw_point(action[\"params\"], self.__screen)\n        if action[\"type\"] == \"Line\":\n            draw_line(action[\"params\"], self.__screen)\n        if action[\"type\"] == \"Text_box\":\n            draw_textbox(action[\"params\"], self.__screen)\n        if action[\"type\"] == \"rect\":\n            draw_rect(action[\"params\"], self.__screen)\n        if action[\"type\"] == \"circle\":\n            draw_circle(action[\"params\"], self.__screen)\n\n    def load_actions(self, hist):\n        \"\"\"\n        Load actions from history\n\n        :param hist: list of dict representing the history of actions in the whiteboard session\n        :return:\n        \"\"\"\n\n        # Sort actions chronologically\n        sred = sorted(hist[\"actions\"],\n                      key=lambda value: value[\"timestamp\"])\n\n        # Go through each action and draw it\n        for action in sred:\n            self.draw_action(action)\n        pygame.display.flip()\n\n    def start(self, connexion_avec_serveur):\n        \"\"\"\n        Start and run a whiteboard window\n\n        :param connexion_avec_serveur: socket to connect with server (socket.socket)\n        :return:\n        \"\"\"\n\n        # Initialize timestamp\n        last_timestamp_sent = 0\n\n        while not self.is_done():\n\n            # Browse all events done by user\n            for event in pygame.event.get():\n                # If user closes the window, quit the whiteboard\n                if self.get_config([\"mode\"]) == \"quit\":\n                    self.end()\n                    break\n                # Use specific handling method for current drawing mode\n                self.__handler[self.get_config([\"mode\"])].handle_all(event)\n\n            # msg_a_envoyer[\"message\"] = \"CARRY ON\"\n            # Send dict history to server\n            if self._hist[\"auth\"] != [self._name, self._erasing_auth]:\n                self._hist[\"auth\"] = []\n            new_modifs = [modif for modif in self.get_hist()[\"actions\"] if\n                          (modif[\"timestamp\"] > last_timestamp_sent and self._name == modif[\"client\"])]\n            message_a_envoyer = {\"message\": \"\", 'actions': new_modifs, \"auth\": self._hist[\"auth\"]}\n            connexion_avec_serveur.send(dict_to_binary(message_a_envoyer))\n\n            self._hist[\"auth\"] = []\n            # Update last timestamp sent\n            if new_modifs:\n                last_timestamp_sent = max([modif[\"timestamp\"] for modif in new_modifs])\n\n            # Dict received from server\n            try:\n                new_hist = binary_to_dict(connexion_avec_serveur.recv(2 ** 24))\n            except (ConnectionResetError, ConnectionAbortedError) as e:\n                print(\"Le serveur a \u00e9t\u00e9 \u00e9teint, veuillez le relancer\")\n                self._done = True\n                pass\n\n            # Consider actions made by another client after new_last_timestamp\n            new_actions = [action for action in new_hist[\"actions\"] if action[\"client\"] != self._name]\n            for action in new_actions:\n                # Here there are two cases, a new figure (point, line, rect, circle, new text box) is created or an\n                # existing text box is modified. For this second case, we use the variable \"matched\" as indicator\n                matched = False\n                if action[\"type\"] == \"Text_box\":\n                    # Find the text box id\n                    for textbox in [x for x in self._hist[\"actions\"] if x[\"type\"] == \"Text_box\"]:\n                        if action[\"id\"] == textbox[\"id\"]:\n                            # Modify it with the newly acquired parameters from server\n                            textbox[\"params\"][\"text\"], textbox[\"params\"][\"w\"] = action[\"params\"][\"text\"], \\\n                                                                                action[\"params\"][\"w\"]\n                            action_to_update_textbox = action\n                            for element in self.get_text_boxes():\n                                if element.id_counter == action[\"id\"]:\n                                    self.del_text_box(element)\n                                    self.append_text_box(TextBox(**action_to_update_textbox[\"params\"]))\n\n                            # Draw the modified text box with updated parameters\n                            self.clear_screen()\n                            self.load_actions(self._hist)\n                            matched = True\n                # If we are in the first case, we add the new actions to history and draw them\n                if not matched:\n                    self.add_to_hist(action)\n                    if action[\"type\"] == \"Text_box\":\n                        self.append_text_box(TextBox(**action[\"params\"]))\n                    self.draw_action(action)\n            if self._name in new_hist[\"auth\"]:\n                new_hist[\"auth\"].remove(self._name)\n            if new_hist[\"auth\"] != self.__modification_allowed:\n                self.__modification_allowed = copy.deepcopy(new_hist[\"auth\"])\n            pygame.display.flip()\n\n        # Once we are done, we quit pygame and send end message\n        pygame.quit()\n        print(\"Fermeture de la connexion\")\n        message_a_envoyer[\"message\"] = \"END\"\n        try:\n            connexion_avec_serveur.send(dict_to_binary(message_a_envoyer))\n        except (ConnectionResetError, BrokenPipeError) as e:\n            print(\"Il n'y a pas de message \u00e0 envoyer au serveur\")\n        connexion_avec_serveur.close()\n\n    def start_local(self):\n        \"\"\"\n        Starts Whiteboard locally. Used to test stuff and debug.\n        :return:\n        \"\"\"\n        while not self.is_done():\n            for event in pygame.event.get():\n                if self.get_config([\"mode\"]) == \"quit\":\n                    self.end()\n                    break\n                self.__handler[self.get_config([\"mode\"])].handle_all(event)\n            pygame.display.flip()\n        pygame.quit()\n"}, {"blob_id": "99a769c3ef254fc29e655b6aa071549404676f3b", "path": "/README.md", "content_id": "928c5d2a92bf19076e12ebc48ff32a07b71237da", "language": "Markdown", "length_bytes": 4561, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.7474994659423828, "alpha_fraction": 0.7343854308128357, "num_lines": 109, "avg_line_length": 40.24770736694336, "max_line_length": 87}], "num_files": 8}
{"repo_name": "Rhaptos/Products.Lensmaker", "repo_url": "https://github.com/Rhaptos/Products.Lensmaker", "snapshot_id": "900d7902c26b27661a9d655a531a70f8a8751a59", "revision_id": "20763e923700d28477850b9bf9a85c69307df04a", "directory_id": "b8cc62a4d33694b1505785555b0a0be383f6e63f", "branch_name": "refs/heads/master", "visit_date": "2020-07-21T23:58:23.549187", "revision_date": "2017-03-08T19:19:16", "committer_date": "2017-03-08T19:19:16", "github_id": 6147129, "star_events_count": 0, "fork_events_count": 1, "gha_license_id": null, "gha_created_at": "2012-10-09T20:19:00", "gha_updated_at": "2014-03-28T15:02:25", "gha_pushed_at": "2017-03-07T20:54:38", "gha_language": "Python", "files": [{"blob_id": "1b585b5fba2bf9e415d2545fe3f5d4acf6698449", "path": "/widgets.py", "content_id": "7fd4e4619a5a0a9dce9ce69cee1bf7d10ca4eeb1", "language": "Python", "length_bytes": 743, "detected_licenses": [], "license_type": "no_license", "src_encoding": "UTF-8", "is_vendor": false, "is_generated": false, "alphanum_fraction": 0.6850605607032776, "alpha_fraction": 0.6810228824615479, "num_lines": 21, "avg_line_length": 34.33333206176758, "max_line_length": 95, "content": "from Products.Archetypes.public import StringWidget\nfrom Products.Archetypes.Registry import registerWidget\n\nclass ColorWidget(StringWidget):\n    _properties = StringWidget._properties.copy()\n    _properties.update({\n        'macro' : \"colorchooser\",\n        })\n\n\nregisterWidget(ColorWidget,\n             title='Color',\n             description='Like StringWidget, stores the hex value of a color.',\n             used_for=('Products.Archetypes.Field.StringField',)\n             )\n\n\nfrom Products.validation import validation\nfrom Products.validation.validators import RegexValidator\nvalidation.register(RegexValidator('isHexColor', r'^[0-9a-fA-F]{6}$', title='', description='',\n                   errmsg='is not a hexadecimal color code.'))\n\n"}], "num_files": 1}